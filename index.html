<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8" />
		<meta name="description" content="Brickoff by Mauro Braunstein" />
		<meta name="keywords" content="brickout, air hockey, arcade, game" />
		<title>Brickoff</title>
		<link rel="icon" href="../synth/favicon.ico" type="image/x-icon">
		<link href="brickoff.css" rel="stylesheet" type="text/css" />
		<script type="text/javascript">
		
		
		
		
		
		
		
		
		
		
		
/********************************************************\
 ██████╗ ██╗      ██████╗ ██████╗  █████╗ ██╗     ███████╗
██╔════╝ ██║     ██╔═══██╗██╔══██╗██╔══██╗██║     ██╔════╝
██║  ███╗██║     ██║   ██║██████╔╝███████║██║     ███████╗
██║   ██║██║     ██║   ██║██╔══██╗██╔══██║██║     ╚════██║
╚██████╔╝███████╗╚██████╔╝██████╔╝██║  ██║███████╗███████║
 ╚═════╝ ╚══════╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝
\********************************************************/		
		
// globals (probably could use a global object and not clutter up the namespace.  Probably)
var debug = false;
var gameCanvas;
var gameCtx;
var audioCtx = new AudioContext();
var audioPlayer;
var soundBank;
var titleScreen;
var levelScreen;
var endingScreen;
var player;
var collisions;

var globalOptions = {
	mspf: 1000.0/180.0, // ms per frame, opposite of fps
	drawFrames: 3, // how many update frames for every draw frame
	mspa: 1000.0/audioCtx.sampleRate // ms per audio frame, opposite of sample rate
};

var gameState = {
	title: true,
	level: false,
	ending: false,
	paused: false
};

var C1 = 440.0/Math.pow(2, 45.0/12.0); // frequency of C1

/*****************************************\
██████╗  █████╗ ███████╗██╗ ██████╗███████╗
██╔══██╗██╔══██╗██╔════╝██║██╔════╝██╔════╝
██████╔╝███████║███████╗██║██║     ███████╗
██╔══██╗██╔══██║╚════██║██║██║     ╚════██║
██████╔╝██║  ██║███████║██║╚██████╗███████║
╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝ ╚═════╝╚══════╝
\*****************************************/

function load() { // initialization
	gameCanvas = document.getElementById('game');
	gameCtx = gameCanvas.getContext('2d');
	titleScreen.initTitle();
	document.addEventListener('mouseout', onMouseOut, false);
	document.addEventListener('mousemove', onMouseMove, false);
	document.addEventListener('mousedown', onMouseDown, false);
	document.addEventListener('mouseup', onMouseUp, false);
	document.addEventListener('keyup', onKeyUp, false);
	document.addEventListener('keydown', onKeyDown, false);
	var drawNow = 0;
	var drawFrames = globalOptions.drawFrames;
	var mainLoop = function () {
		if (!gameState.paused) {
			update();
			if (drawNow == 0) draw();
			drawNow = (drawNow + 1) % drawFrames;
		}
	}
	setInterval(mainLoop, globalOptions.mspf);
	audioPlayer.initAudio();
}

function update() { // update the game
	if (gameState.title) titleScreen.update();
	else if (gameState.level) levelScreen.update();
	else if (gameState.ending) endingScreen.update();
}

function draw() { // render the scene
	if (gameState.title) titleScreen.draw();
	else if (gameState.level) levelScreen.draw();
	else if (gameState.ending) endingScreen.draw();
}

/**********************************************************\
██╗   ██╗████████╗██╗██╗     ██╗████████╗██╗███████╗███████╗
██║   ██║╚══██╔══╝██║██║     ██║╚══██╔══╝██║██╔════╝██╔════╝
██║   ██║   ██║   ██║██║     ██║   ██║   ██║█████╗  ███████╗
██║   ██║   ██║   ██║██║     ██║   ██║   ██║██╔══╝  ╚════██║
╚██████╔╝   ██║   ██║███████╗██║   ██║   ██║███████╗███████║
 ╚═════╝    ╚═╝   ╚═╝╚══════╝╚═╝   ╚═╝   ╚═╝╚══════╝╚══════╝
\**********************************************************/

function clearCanvas() { // clears the canvas
	gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
}

function drawOutline(fillColor, strokeColor) {
	gameCtx.strokeStyle = fillColor;
	gameCtx.lineWidth = 5;
	drawBorder(2.5);
	gameCtx.strokeStyle = strokeColor;
	gameCtx.lineWidth = 1;
	drawBorder(0.5);
	drawBorder(4.5);
}

function drawBorder(offset) { // draws a border at the given offset with current stroke style
	gameCtx.strokeRect(offset, offset, gameCanvas.width - 2*offset, gameCanvas.height - 2*offset);
}

function distance(x1, y1, x2, y2) { // distance between two points
	return Math.sqrt((x2 - x1)*(x2 - x1) + (y2 - y1)*(y2 - y1));
}

function rgba(r, g, b, a) { // make RGBA string
	// they need to be integers
	r = Math.floor(r + 0.5);
	g = Math.floor(g + 0.5);
	b = Math.floor(b + 0.5);
	// they also need to be in range
	if (r < 0) r = 0;
	if (r > 255) r = 255;
	if (g < 0) g = 0;
	if (g > 255) g = 255;
	if (b < 0) b = 0;
	if (b > 255) b = 255;
	if (a < 0) a = 0;
	if (a > 1.0) a = 1.0;
	return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}

// UNTESTED
function hsla(h, s, l, a) { // make HSLA string
	// h is integer, s and l are integer percentages
	// s, l, and a should be from 0 to 1; h should be from 0 to 360
	h = Math.floor(r + 0.5);
	if (h < 0) h = 0;
	if (h > 359) h = 359;
	if (s < 0) s = 0;
	if (s > 1) s = 1;
	if (l < 0) l = 0;
	if (l > 1) l = 1;
	if (a < 0) a = 0;
	if (a > 1) a = 1;
	s = Math.floor(100*s);
	l = Math.floor(100*l);
	return 'hsla(' + h + ',' + s + '%,' + l + '%,' + a + ')';
}

// generates r, g, b for a random color chosen uniformly from the HSV cone
function randomColor() {
	var h = Math.random()*6;
	var s = Math.pow(Math.random(), 1.0/2.0);
	var v = Math.pow(Math.random(), 1.0/3.0);
	var c = s*v;
	var color = {
		r: 0,
		g: 0,
		b: 0
	}; // this will be updated
	if (h < 1) {
		color.r = 1;
		color.g = h;
	} else if (h < 2) {
		color.r = 2 - h;
		color.g = 1;
	} else if (h < 3) {
		color.g = 1;
		color.b = h - 2;
	} else if (h < 4) {
		color.g = 4 - h;
		color.b = 1;
	} else if (h < 5) {
		color.r = h - 4;
		color.b = 1;
	} else if (h < 6) {
		color.r = 1;
		color.b = 6 - h;
	}
	color.r = 256*(c*(color.r) + v - c);
	color.g = 256*(c*(color.g) + v - c);
	color.b = 256*(c*(color.b) + v - c);
	return color;
}

// whether an angle is between t1 and t2, where t1 < t2
function angleInRange(angle, t1, t2) {
	while (angle >= t1) angle -= 2*Math.PI;
	while (angle < t1) angle += 2*Math.PI;
	if (t1 <= angle && angle <= t2) return true;
	return false;
}

/***********************************************\
██████╗ ██╗      █████╗ ██╗   ██╗███████╗██████╗ 
██╔══██╗██║     ██╔══██╗╚██╗ ██╔╝██╔════╝██╔══██╗
██████╔╝██║     ███████║ ╚████╔╝ █████╗  ██████╔╝
██╔═══╝ ██║     ██╔══██║  ╚██╔╝  ██╔══╝  ██╔══██╗
██║     ███████╗██║  ██║   ██║   ███████╗██║  ██║
╚═╝     ╚══════╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═╝
\***********************************************/

player = {
	lives: undefined,
	powerups: undefined,
	score: undefined
}

player.initPlayer = function () {
	this.lives = 0;
	this.score = 0; // not sure if we want to implement score...
	this.powerups = {}; // none of these yet
}

player.die = function () {
	this.lives--;
	if (this.lives < 0 && gameState.level) levelScreen.gameOver();
}

/*****************************************************************************************\
████████╗██╗████████╗██╗     ███████╗    ███████╗ ██████╗██████╗ ███████╗███████╗███╗   ██╗
╚══██╔══╝██║╚══██╔══╝██║     ██╔════╝    ██╔════╝██╔════╝██╔══██╗██╔════╝██╔════╝████╗  ██║
   ██║   ██║   ██║   ██║     █████╗      ███████╗██║     ██████╔╝█████╗  █████╗  ██╔██╗ ██║
   ██║   ██║   ██║   ██║     ██╔══╝      ╚════██║██║     ██╔══██╗██╔══╝  ██╔══╝  ██║╚██╗██║
   ██║   ██║   ██║   ███████╗███████╗    ███████║╚██████╗██║  ██║███████╗███████╗██║ ╚████║
   ╚═╝   ╚═╝   ╚═╝   ╚══════╝╚══════╝    ╚══════╝ ╚═════╝╚═╝  ╚═╝╚══════╝╚══════╝╚═╝  ╚═══╝
\*****************************************************************************************/

titleScreen = {
	// animation

	// fade in
	fadeInParameter: 0,
	titleInFader: undefined,

	// fade out
	fadeOutParameter: 1,
	titleOutFader: undefined,

	// "Click to Start" blinker
	clickToStartBlinker: undefined,
	clickToStartBlinkTime: 0.5, // in seconds
	clickToStartDraw: false,
	
	// game data
	purpleBallCount: 0,
	numPurpleBalls: 20,
	paddle: undefined,
	walls: [],
	purpleBalls: [],
	
	// misc state
	mouseDown: false
};

titleScreen.initTitle = function () { // set up the title object
	gameState.title = true;

	// set up animation
	this.fadeInParameter = 0;
	this.titleInFader = new Fader(2.5);
	//this.titleInFader.fadeInFormula = 'quadratic';
	this.titleInFader.start();
	
	// initialize fadeout, though it won't happen for a while
	this.fadeOutParameter = 1;
	this.titleOutFader = new Fader(0.0, 0.0, 1.5);
	
	// reset blinker
	this.clickToStartDraw = false;
	this.clickToStartBlinker = undefined;
	
	// reset purple balls
	this.purpleBallCount = 0;
	this.purpleBalls = [];
	
	// reset paddle
	this.paddle = undefined;
	
	// build up walls
	var wallL = new Wall(5, 5, 5, gameCanvas.height - 5); // create wall objects for collisions
	var wallR = new Wall(gameCanvas.width - 5, 5, gameCanvas.width - 5, gameCanvas.height - 5);
	var wallT = new Wall(5, 5, gameCanvas.width - 5, 5);
	var wallB = new Wall(5, gameCanvas.height - 5, gameCanvas.width - 5, gameCanvas.height - 5);
	this.walls = [wallL, wallR, wallT, wallB];
	
	//diagnoseTitle();
};

titleScreen.update = function () { // update the title screen
	if (this.titleInFader.mode == 'active') {
		this.titleInFader.update();
		this.fadeInParameter = this.titleInFader.fadeParameter;
	} else {
		this.fadeInParameter = 1.0;
		if (!this.paddle) this.initPaddle();
		if (!this.clickToStartBlinker) this.initClickToStartBlinker();
		if (this.purpleBallCount < this.numPurpleBalls) this.generatePurpleBall();
	}
	if (this.titleOutFader.mode == 'active') {
		this.titleOutFader.update();
		this.fadeOutParameter = this.titleOutFader.fadeParameter;
	} else if (this.titleOutFader.mode == 'done') {
		this.fadeOutParameter = 0.0;
		this.endTitle();
	}
	// no need to update walls
	for (var o = 0; o < this.purpleBalls.length; o++) {
		this.purpleBalls[o].update();
	}
	if (this.paddle) {
		this.paddle.update();
		for (var w = 0; w < this.walls.length; w++) {
			collide(this.walls[w], this.paddle);
		}
	}
	for (var o = 0; o < this.purpleBalls.length; o++) { // check for collisions
		for (var w = 0; w < this.walls.length; w++) {
			collide(this.walls[w], this.purpleBalls[o]);
		}
		for (var o2 = o + 1; o2 < this.purpleBalls.length; o2++) {
			collide(this.purpleBalls[o], this.purpleBalls[o2]);
		}
		if (this.paddle) collide(this.purpleBalls[o], this.paddle);
		//this.objectList[o].update();
		if (this.purpleBalls[o].remove) {
			this.purpleBalls[o].death();
			this.purpleBalls.splice(o,1);
			o--;
		}
	}
};

titleScreen.draw = function () {
	clearCanvas();
	this.drawBackground();
	this.drawOutline();
	for (var o = 0; o < this.purpleBalls.length; o++) {
		this.purpleBalls[o].draw();
	}
	if (this.paddle) this.paddle.draw();
	this.drawTitle();
}

titleScreen.initClickToStartBlinker = function () {
	var toggleClickToStart = function () {
		titleScreen.clickToStartDraw = !titleScreen.clickToStartDraw;
	};
	this.clickToStartBlinker = setInterval(toggleClickToStart, titleScreen.clickToStartBlinkTime*1000);
};

titleScreen.initPaddle = function () {
	var paddle = new PlayerPaddle(gameCanvas.width*0.5, gameCanvas.height*0.8, 50);
	this.paddle = paddle;
}

titleScreen.drawTitle = function () {
	gameCtx.fillStyle = 'rgba(237,237,237,' + this.fadeInParameter * this.fadeOutParameter + ')';
	gameCtx.strokeStyle = 'rgba(140,32,32, ' + this.fadeOutParameter + ')';
	gameCtx.lineWidth = 3;
	gameCtx.font = 'bold 96px serif';
	var brickoffWidth = gameCtx.measureText('BRICKOFF!').width;
	gameCtx.fillText('BRICKOFF!', gameCanvas.width*0.5 - brickoffWidth*0.5, gameCanvas.height*0.5 + 18);
	gameCtx.strokeText('BRICKOFF!', gameCanvas.width*0.5 - brickoffWidth*0.5, gameCanvas.height*0.5 + 18);
	if (this.clickToStartDraw) {
		gameCtx.font = '32px serif';
		var clickToStartWidth = gameCtx.measureText('Click to Start').width;
		gameCtx.fillText('Click to Start', gameCanvas.width*0.5 - clickToStartWidth*0.5, gameCanvas.height*0.5 + 90);
	}
	//gameCtx.fillStyle = 'rgba(237,237,237,' + this.fadeInParameter * this.fadeOutParameter + ')';
		// straight from microtonal synthesizer
	gameCtx.font = '72px serif';
	var offtonicWidth = gameCtx.measureText('Offtonic').width;
	gameCtx.fillText('Offtonic', gameCanvas.width*0.5 - offtonicWidth*0.5, 96);
};

titleScreen.drawBackground = function () {
	gameCtx.fillStyle = '#1E1E1E';
	gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
	gameCtx.fillStyle = 'rgba(0,0,0,' + this.fadeInParameter * this.fadeOutParameter + ')';;
	gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
};

titleScreen.drawOutline = function () {
	drawOutline('rgba(0,0,30,' + this.fadeInParameter * this.fadeOutParameter + ')',
		'rgba(64,64,255,' + this.fadeInParameter * this.fadeOutParameter + ')');
};

titleScreen.generatePurpleBall = function () {
	var radius = 8 + 52 * (Math.random() * Math.random());
	var v = 400*(90 + 150 * Math.random())/(radius*radius);
	var theta = 2 * Math.PI * Math.random();
	var vx = v*Math.cos(theta);
	var vy = v*Math.sin(theta);
	var x = 0;
	var y = 0;
	if (theta > 7*Math.PI/4 && theta <= Math.PI/4) {
		x = -2*radius;
		y = gameCanvas.height*Math.random();
	} else if (theta > Math.PI/4 && theta <= 3*Math.PI/4) {
		y = -2*radius;
		x = gameCanvas.width*Math.random();
	} else if (theta > 3*Math.PI/4 && theta <= 5*Math.PI/4) {
		x = gameCanvas.width + 2*radius;
		y = gameCanvas.height*Math.random();
	} else if (theta > 5*Math.PI/4 && theta <= 7*Math.PI/4) {
		y = gameCanvas.height + 2*radius;
		x = gameCanvas.width*Math.random();
	}
	var b = new PurpleBall(x, y, vx, vy, radius);
	this.purpleBalls.push(b);
	this.purpleBallCount++;
};

titleScreen.mouseMove = function (x, y) {
	if (this.paddle) this.paddle.move(x,y);
};

titleScreen.mouseUp = function (x, y) {
	//console.log('Mouse up!');
	if (this.clickToStartBlinker) {
		clearInterval(this.clickToStartBlinker);
		this.clickToStartDraw = true;
		this.fadingOut = true;
		this.titleOutFader.start();
	}
};

titleScreen.endTitle = function () {
	gameState.title = false;
	levelScreen.initGame();
};

function diagnoseTitle() {
	console.log('Diagnosing title... purpleBalls has ' + titleScreen.purpleBalls.length + ' objects');
	for (var o = 0; o < titleScreen.purpleBalls.length; o++) {
		var obj = titleScreen.purpleBalls[o];
		if (obj.type == 'Wall') {
			console.log('Wall from (' + obj.x1 + ',' + obj.y1 + ') to (' + obj.x2 + ',' + obj.y2 + ')');
		} else if (obj.type == 'PurpleBall') {
			console.log('PurpleBall with center (' + obj.x + ',' + obj.y + ') and radius ' + obj.radius);
			console.log('Velocity: <' + obj.vx + ',' + obj.vy + '>');
		}
	}
}

/*********************************************************************************************\
██╗     ███████╗██╗   ██╗███████╗██╗         ███████╗ ██████╗██████╗ ███████╗███████╗███╗   ██╗
██║     ██╔════╝██║   ██║██╔════╝██║         ██╔════╝██╔════╝██╔══██╗██╔════╝██╔════╝████╗  ██║
██║     █████╗  ██║   ██║█████╗  ██║         ███████╗██║     ██████╔╝█████╗  █████╗  ██╔██╗ ██║
██║     ██╔══╝  ╚██╗ ██╔╝██╔══╝  ██║         ╚════██║██║     ██╔══██╗██╔══╝  ██╔══╝  ██║╚██╗██║
███████╗███████╗ ╚████╔╝ ███████╗███████╗    ███████║╚██████╗██║  ██║███████╗███████╗██║ ╚████║
╚══════╝╚══════╝  ╚═══╝  ╚══════╝╚══════╝    ╚══════╝ ╚═════╝╚═╝  ╚═╝╚══════╝╚══════╝╚═╝  ╚═══╝
\*********************************************************************************************/

levelScreen = {
	// basics
	level: undefined,
	levelWon: false,
	death: false,
	
	// animation
	titleFader: undefined,
	levelFader: undefined,
	levelOutFader: undefined,
	deathFader: undefined,
	
	// game objects
	balls: undefined,
	bricks: undefined,
	walls: undefined,
	paddle: undefined,
	
	// misc state
	mouseDown: false,
	retrieveLostBallNext: false,

	// level geometry -- it's set by each level anyway
	tb: 50, // top buffer between end of canvas and wall
	bb: 50, // bottom buffer
	lb: 50, // left buffer
	rb: 50, // right buffer
	cornerRadius: 100, // corner radius
	goalWidth: 250, // width of goal area along bottom wall
	goalRadius: 45, // radius of goal's rounded edges;
	extraRadius: 5, // if the goal radius is too big, this smoothes out the hidden goal corner
	edgeWidth: 5, // width of edge around game canvas

	// level data
	levelData: {
		1: {
			title: 'In C',
			newLives: 5,
			geometry: {
				cornerRadius: 100,
				tb: 50,
				bb: 50,
				lb: 50,
				rb: 50,
				goalWidth: 250,
				goalRadius: 45
			},
			initWalls: 'initWallsRounded',
			initBricks: 'initBricks1',
			initPaddleAndBall: 'initPaddleAndBallA',
			drawGameWall: 'drawGameWallRounded',
			gradients: 'gradientsA',
			outlineFill: {
				r: 30,
				g: 0,
				b: 0
			},
			outlineStroke: {
				r: 255,
				g: 64,
				b: 64
			}
		},
		2: {
			title: 'Many Colors',
			newLives: 1,
			geometry: {
				cornerRadius: 25,
				tb: 50,
				bb: 50,
				lb: 50,
				rb: 50,
				goalWidth: 250,
				goalRadius: 25
			},
			initWalls: 'initWallsRounded',
			initBricks: 'initBricks2',
			initPaddleAndBall: 'initPaddleAndBallA',
			drawGameWall: 'drawGameWallRounded',
			gradients: 'gradientsB',
			outlineFill: {
				r: 30,
				g: 15,
				b: 0
			},
			outlineStroke: {
				r: 255,
				g: 160,
				b: 64
			}
		},
		3: {
			title: 'Squares',
			newLives: 1,
			geometry: {
				cornerRadius: 100,
				tb: 50,
				bb: 50,
				lb: 50,
				rb: 50,
				goalWidth: 250,
				goalRadius: 0
			},
			initWalls: 'initWallsB',
			initBricks: 'initBricks3',
			initPaddleAndBall: 'initPaddleAndBallA',
			drawGameWall: 'drawGameWallB',
			gradients: 'gradientsC',
			outlineFill: {
				r: 30,
				g: 30,
				b: 0
			},
			outlineStroke: {
				r: 255,
				g: 255,
				b: 64
			}
		}
	}
};

levelScreen.initGame = function () {
	player.initPlayer();
	this.initLevel(1);
}

levelScreen.initLevel = function (n) {
	//console.log('init level ' + n);
	gameState.level = true;
	this.level = n;
	this.levelWon = false;
	this.death = false;
	this.retrieveLostBallNext = false;

	// fading
	this.titleFader = new Fader(1.0, 1.0, 1.0); // fade in for 1 second, wait for 1 second, fade out for 1 second
	this.titleFader.start();
	this.levelFader = new Fader(1.0, 0.0, 1.0); // fade in for 1 second, then out for 1 second, but we're going to pause it
	this.endingFader = new Fader(1.0, 1.0, 1.0); // same as title fader
	this.deathFader = undefined;
	
	// reset paddle and balls
	this.paddle = undefined;
	this.balls = [];
	this.bricks = [];

	// set geometry
	var geometry = this.levelData[this.level]['geometry'];
	this.cornerRadius = geometry.cornerRadius;
	this.tb = geometry.tb;
	this.bb = geometry.bb;
	this.lb = geometry.lb;
	this.rb = geometry.rb;
	this.goalWidth = geometry.goalWidth;
	this.goalRadius = geometry.goalRadius;

	// make walls
	this[this.levelData[this.level]['initWalls']]();

	// edit player lives
	player.lives += this.levelData[this.level]['newLives'];
};

levelScreen.levelStart = function () {
	this[this.levelData[this.level]['initPaddleAndBall']]();
	this[this.levelData[this.level]['initBricks']]();
};

levelScreen.nextLevel = function () {
	if (this.level >= 2) { // max level; put this variable elsewhere
		gameState.level = false;
		endingScreen.gameWon();
	} else {
		levelScreen.initLevel(this.level + 1);
	}
};

levelScreen.gameOver = function () {
	gameState.level = false;
	endingScreen.gameOver();
};

levelScreen.mouseMove = function (x, y) {
	if (this.paddle) this.paddle.move(x,y);
};

levelScreen.mouseUp = function (x, y) {
	this.retrieveLostBallNext = true;
};

levelScreen.capture = function () {
	for (var b = 0; b < this.balls.length; b++) {
		this.paddle.capture(this.balls[b]);
	}
};

levelScreen.reviseCapture = function () {
	this.paddle.capturing = false;
	for (var b = 0; b < this.balls.length; b++) {
		this.paddle.reviseCapture(this.balls[b]);
	}
};

levelScreen.retrieveLostBall = function () {
	var lostBall = false;
	for (var b = 0; b < this.balls.length; b++) {
		if (this.balls[b].expired) lostBall = true;
	}
	if (!lostBall) return;
	var minTouch = this.balls[0].lastTouched + 1;
	var minBall = -1;
	for (var b = 0; b < this.balls.length; b++) {
		if (this.balls[b].lastTouched < minTouch) {
			minTouch = this.balls[b].lastTouched;
			minBall = b;
		}
	}
	this.paddle.capturing = true;
	this.balls[minBall].captured = this.paddle;
	this.balls[minBall].x = this.paddle.x + (4*Math.random() - 2); // don't center it to prevent concentric collisions
	this.balls[minBall].y = this.paddle.y + (4*Math.random() - 2);
	this.balls[minBall].lastPosition.x = this.balls[minBall].x;
	this.balls[minBall].lastPosition.y = this.balls[minBall].y;
	this.balls[minBall].vx = 0;
	this.balls[minBall].vy = 0;
};

/*********************************************************************************************\
██╗     ███████╗██╗   ██╗███████╗██╗         ██╗   ██╗██████╗ ██████╗  █████╗ ████████╗███████╗
██║     ██╔════╝██║   ██║██╔════╝██║         ██║   ██║██╔══██╗██╔══██╗██╔══██╗╚══██╔══╝██╔════╝
██║     █████╗  ██║   ██║█████╗  ██║         ██║   ██║██████╔╝██║  ██║███████║   ██║   █████╗  
██║     ██╔══╝  ╚██╗ ██╔╝██╔══╝  ██║         ██║   ██║██╔═══╝ ██║  ██║██╔══██║   ██║   ██╔══╝  
███████╗███████╗ ╚████╔╝ ███████╗███████╗    ╚██████╔╝██║     ██████╔╝██║  ██║   ██║   ███████╗
╚══════╝╚══════╝  ╚═══╝  ╚══════╝╚══════╝     ╚═════╝ ╚═╝     ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚══════╝
\*********************************************************************************************/

levelScreen.update = function () {
	if (this.paddle) {
		if (this.mouseDown) {
			this.paddle.lifted = true;
			this.paddle.capturing = false;
		} else {
			if (this.paddle.lifted) this.capture();
			else if (this.paddle.capturing) this.reviseCapture();
		}
		if (this.retrieveLostBallNext) {
			this.retrieveLostBall();
			this.retrieveLostBallNext = false;
		}
	}
	if (this.levelFader && this.levelFader.mode === 'paused' && !this.death) {
		// updates
		if (this.paddle) this.paddle.update();
		for (var b = 0; b < this.balls.length; b++) {
			this.balls[b].update();
			// check if ball has disappeared
			if (this.balls[b].y > gameCanvas.height + this.balls[b].radius) this.balls[b].remove = true;
		}
		for (var b = 0; b < this.bricks.length; b++) {
			this.bricks[b].update();
		}
		// collisions
		if (this.paddle) {
			for (var w = 0; w < this.walls.length; w++) {
				collide(this.walls[w], this.paddle);
			}
		}
		for (var b = 0; b < this.balls.length; b++) {
			for (var w = 0; w < this.walls.length; w++) {
				collide(this.walls[w], this.balls[b]);
			}
			for (var b2 = b + 1; b2 < this.balls.length; b2++) {
				collide(this.balls[b], this.balls[b2]);
			}
			for (var b2 = 0; b2 < this.bricks.length; b2++) {
				collide(this.balls[b], this.bricks[b2]);
			}
			if (this.paddle) collide(this.balls[b], this.paddle);
		}
		for (var b = 0; b < this.bricks.length; b++) {
			for (var w = 0; w < this.walls.length; w++) {
				collide(this.walls[w], this.bricks[b]);
			}
			for (var b2 = b + 1; b2 < this.bricks.length; b2++) {
				collide(this.bricks[b], this.bricks[b2]);
			}
			if (this.paddle) collide(this.bricks[b], this.paddle);
		}
		// remove dead objects
		for (var b = 0; b < this.balls.length; b++) {
			if (this.balls[b].remove) {
				this.balls[b].death();
				this.balls.splice(b,1);
				b--;
			}
		}
		for (var b = 0; b < this.bricks.length; b++) {
			if (this.bricks[b].remove) {
				this.bricks[b].death();
				this.bricks.splice(b,1);
				b--;
			}
		}
		// check whether balls have expired (been left untouched too long)
		for (var b = 0; b < this.balls.length; b++) {
			if (this.balls[b].lastTouched > this.balls[b].expiration) this.balls[b].expired = true;
		}
		// check whether the level has been won
		if (!this.levelWon && this.bricks.length == 0) {
			this.levelWon = true;
			this.paddle = undefined;
			this.balls = [];
			this.endingFader.start();
			this.levelFader.start();
		}
		// check whether all balls have been lost
		if (!this.levelWon && this.balls.length == 0) {
			this.death = true;
			soundBank.death();
			if (player.lives > 0) {
				this.deathFader = new Fader(0.5, 0.1, 0.5);
			} else {
				this.deathFader = new Fader(1.5);
				this.death = 'final';
			}
			this.deathFader.invertFader();
			this.deathFader.fadeParameter = 1.0;
			this.deathFader.start();
		}
	} else if (this.death) {
		if (this.deathFader) this.deathFader.update();
		if ((this.deathFader && this.deathFader.fadeMode == 'fadeOut' && this.balls.length == 0) ||
			(this.death == 'final' && this.deathFader && this.deathFader.mode == 'done')) {
			this.paddle = undefined;
			player.die();
			if (player.lives >= 0) {
				this[this.levelData[this.level]['initPaddleAndBall']]();
			}
		} else if (this.deathFader && this.deathFader.mode == 'done') {
			this.death = false;
			this.deathFader = undefined;
		}
	} else {
		if (this.titleFader) this.titleFader.update();
		if (this.levelFader) this.levelFader.update();
		if (this.endingFader) this.endingFader.update();
		if (this.levelFader && this.levelFader.mode == 'inactive' && this.titleFader && this.titleFader.fadeMode == 'fadeOut') {
			this.levelFader.start();
			this.levelStart();
		}
		if (this.titleFader && this.titleFader.mode == 'done' && this.levelFader && this.levelFader.fadeMode == 'fadeOut') {
			this.titleFader = undefined;
			this.levelFader.pause();
		}
		if (this.levelFader && this.levelFader.mode == 'done') {
			this.levelFader = undefined;
		}
		if (this.endingFader && this.endingFader.mode == 'done') {
			this.endingFader = undefined;
			this.nextLevel();
		}
	}
};

/*****************************************************************************\
██╗     ███████╗██╗   ██╗███████╗██╗         ██████╗ ██████╗  █████╗ ██╗    ██╗
██║     ██╔════╝██║   ██║██╔════╝██║         ██╔══██╗██╔══██╗██╔══██╗██║    ██║
██║     █████╗  ██║   ██║█████╗  ██║         ██║  ██║██████╔╝███████║██║ █╗ ██║
██║     ██╔══╝  ╚██╗ ██╔╝██╔══╝  ██║         ██║  ██║██╔══██╗██╔══██║██║███╗██║
███████╗███████╗ ╚████╔╝ ███████╗███████╗    ██████╔╝██║  ██║██║  ██║╚███╔███╔╝
╚══════╝╚══════╝  ╚═══╝  ╚══════╝╚══════╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝ ╚══╝╚══╝ 
\*****************************************************************************/

levelScreen.draw = function () {
	//console.log('draw level');
	var deathFadeParameter = this.deathFader ? this.deathFader.fadeParameter : 1.0;
	var levelFadeParameter = this.levelFader ? this.levelFader.fadeParameter : 1.0;
	var f = deathFadeParameter * levelFadeParameter;
	this.drawBackground();
	this.drawOutline();
	if (this.titleFader) this.drawTitle();
	if (this.endingFader && this.endingFader.mode != 'inactive') this.drawEnding();
	if ((!this.endingFader || this.endingFader.mode == 'inactive') && (!this.levelFader || this.levelFader.mode != 'inactive')) this.drawGameWall(f);
	for (var w = 0; w < this.walls.length; w++) this.walls[w].draw(f);
	for (var b = 0; b < this.balls.length; b++) this.balls[b].draw(f);
	for (var b = 0; b < this.bricks.length; b++) this.bricks[b].draw(f);
	if (this.paddle) this.paddle.draw(f);
	if (this.levelFader) this.drawStatus(f);
};

levelScreen.drawBackground = function () {
	if ((this.titleFader && this.titleFader.fadeMode == 'fadeIn') || (this.endingFader && this.endingFader.fadeMode == 'fadeOut') || (this.death == 'final' && this.deathFader)) {
		var fadeParameter = 1;
		if (this.titleFader && this.titleFader.fadeMode == 'fadeIn') fadeParameter = this.titleFader.fadeParameter;
		else if (this.endingFader && this.endingFader.fadeMode == 'fadeOut') fadeParameter = this.endingFader.fadeParameter;
		else if (this.death == 'final' && this.deathFader) fadeParameter = this.deathFader.fadeParameter;
		gameCtx.fillStyle = '#1E1E1E';
		gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
		gameCtx.fillStyle = 'rgba(0,0,0,' + fadeParameter + ')';
		gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
	} else {
		gameCtx.fillStyle = 'rgb(0,0,0)';
		gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
	}
};

levelScreen.drawOutline = function () {
	var f = 1;
	if (this.titleFader && this.titleFader.fadeMode == "fadeIn") f = this.titleFader.fadeParameter;
	else if (this.endingFader && this.endingFader.fadeMode == 'fadeOut') f = this.endingFader.fadeParameter;
	else if (this.deathFader && this.death == 'final') f = this.deathFader.fadeParameter;
	//drawOutline(rgba(0, 0, 30, f), rgba(64, 64, 255, f)); // original blue outline
	var outlineFill = this.levelData[this.level]['outlineFill'];
	var outlineStroke = this.levelData[this.level]['outlineStroke'];
	drawOutline(rgba(outlineFill.r, outlineFill.g, outlineFill.b, f), rgba(outlineStroke.r, outlineStroke.g, outlineStroke.b, f));
};

levelScreen.drawTitle = function () {
	var titleFadeParameter = 0;
	if (this.titleFader && this.titleFader.mode == 'active') titleFadeParameter = this.titleFader.fadeParameter;
	gameCtx.fillStyle = 'rgba(237, 237, 237, ' + titleFadeParameter + ')';
	gameCtx.font = '72px serif';
	var levelNWidth = gameCtx.measureText('Level ' + this.level).width;
	//gameCtx.fillText('Level ' + this.level, gameCanvas.width*0.5 - levelNWidth*0.5, gameCanvas.height*0.5 + 18);
	gameCtx.fillText('Level ' + this.level, gameCanvas.width*0.5 - levelNWidth*0.5, gameCanvas.height*0.5 - 36);
	var titleWidth = gameCtx.measureText(this.levelData[this.level].title).width;
	gameCtx.fillText(this.levelData[this.level].title, gameCanvas.width*0.5 - titleWidth*0.5, gameCanvas.height*0.5 + 54);
}

levelScreen.drawEnding = function () {
	var endingFadeParameter = 0;
	if (this.endingFader && this.endingFader.mode == 'active') endingFadeParameter = this.endingFader.fadeParameter;
	gameCtx.fillStyle = 'rgba(237, 237, 237, ' + endingFadeParameter + ')';
	gameCtx.font = '72px serif';
	var levelNWidth = gameCtx.measureText('Level ' + this.level).width;
	gameCtx.fillText('Level ' + this.level, gameCanvas.width*0.5 - levelNWidth*0.5, gameCanvas.height*0.5 - 36);
	var completeWidth = gameCtx.measureText('Complete').width;
	gameCtx.fillText('Complete', gameCanvas.width*0.5 - completeWidth*0.5, gameCanvas.height*0.5 + 54);
}

levelScreen.drawGameWall = function (f) {
	var gradients = this[this.levelData[this.level]['gradients']](f);
	this[this.levelData[this.level]['drawGameWall']](gradients.stroke, gradients.fill);
}

levelScreen.drawStatus = function (f) {
	if (f === undefined) f = 1;
	// top of screen, at least for now
	gameCtx.fillStyle = 'rgba(237, 237, 237, ' + f + ')';
	gameCtx.font = '36px serif';
	if (player.lives >= 0) {
		var livesWidth = gameCtx.measureText(player.lives).width;
		var livesHeight = 26; // there's no height metric
		gameCtx.fillText(player.lives, gameCanvas.width - this.edgeWidth - livesWidth - 8, this.edgeWidth + livesHeight + 8);
	}
	// X
	gameCtx.strokeStyle = rgba(237, 237, 237, f);
	gameCtx.lineWidth = 2;
	gameCtx.beginPath();
	gameCtx.moveTo(gameCanvas.width - this.edgeWidth - livesWidth - 8 - 16, this.edgeWidth + livesHeight + 8);
	gameCtx.lineTo(gameCanvas.width - this.edgeWidth - livesWidth - 8 - 16 - livesHeight, this.edgeWidth + 8);
	gameCtx.moveTo(gameCanvas.width - this.edgeWidth - livesWidth - 8 - 16, this.edgeWidth + 8);
	gameCtx.lineTo(gameCanvas.width - this.edgeWidth - livesWidth - 8 - 16 - livesHeight, this.edgeWidth + livesHeight + 8);
	gameCtx.stroke();
	// ball icon
	var ballRadius = 15;
	gameCtx.fillStyle = rgba(255, 255, 255, f);
	gameCtx.strokeStyle = rgba(141, 128, 180, f);
	gameCtx.lineWidth = 2;
	gameCtx.beginPath();
	gameCtx.arc(gameCanvas.width - this.edgeWidth - livesWidth - 8 - 16 - livesHeight - 16 - ballRadius, this.edgeWidth + (livesHeight/2.0) + 8, ballRadius, 0, 2*Math.PI, true);
	gameCtx.fill();
	gameCtx.stroke();
}

/*********************************************************************\
 ██████╗ ██████╗  █████╗ ██████╗ ██╗███████╗███╗   ██╗████████╗███████╗
██╔════╝ ██╔══██╗██╔══██╗██╔══██╗██║██╔════╝████╗  ██║╚══██╔══╝██╔════╝
██║  ███╗██████╔╝███████║██║  ██║██║█████╗  ██╔██╗ ██║   ██║   ███████╗
██║   ██║██╔══██╗██╔══██║██║  ██║██║██╔══╝  ██║╚██╗██║   ██║   ╚════██║
╚██████╔╝██║  ██║██║  ██║██████╔╝██║███████╗██║ ╚████║   ██║   ███████║
 ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═════╝ ╚═╝╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝
\*********************************************************************/

levelScreen.gradientsA = function (f) {
	gameCtx.lineWidth = 2;

	// width of border between game wall and canvas wall
	var tb = this.tb - gameCtx.lineWidth/2.0;
	var bb = this.bb - gameCtx.lineWidth/2.0;
	var lb = this.lb - gameCtx.lineWidth/2.0;
	var rb = this.rb - gameCtx.lineWidth/2.0;

	// stroke gradient
	var gStroke = gameCtx.createLinearGradient(0.5*(gameCanvas.width + this.lb - this.rb), tb - 0.5,
		0.5*(gameCanvas.width + this.lb - this.rb), gameCanvas.height - (bb - 0.5));
	gStroke.addColorStop(0,'rgba(128,0,0,' + f + ')');
	gStroke.addColorStop(0.5,'rgba(128,0,0,' + f + ')');
	gStroke.addColorStop(1,'rgba(128,0,0,' + f + ')');
	// fill gradient
	var gFill = gameCtx.createLinearGradient(0.5*(gameCanvas.width + this.lb - this.rb), tb - 0.5,
		0.5*(gameCanvas.width + this.lb - this.rb), gameCanvas.height - (bb - 0.5));
	gFill.addColorStop(0,'rgba(144,0,0,' + f*0.5 + ')');
	gFill.addColorStop(0.5,'rgba(0,0,0,' + f*0.5 + ')');
	gFill.addColorStop(1,'rgba(144,0,0,' + f*0.5 + ')');
	return {
		stroke: gStroke,
		fill: gFill
	}
}

levelScreen.gradientsB = function (f) {
	gameCtx.lineWidth = 2;

	// width of border between game wall and canvas wall
	var tb = this.tb - gameCtx.lineWidth/2.0;
	var bb = this.bb - gameCtx.lineWidth/2.0;
	var lb = this.lb - gameCtx.lineWidth/2.0;
	var rb = this.rb - gameCtx.lineWidth/2.0;

	// stroke gradient
	var gStroke = gameCtx.createLinearGradient(0.5*(gameCanvas.width + this.lb - this.rb), tb - 0.5,
		0.5*(gameCanvas.width + this.lb - this.rb), gameCanvas.height - (bb - 0.5));
	gStroke.addColorStop(0,'rgba(140,32,32,' + f + ')');
	gStroke.addColorStop(0.5, 'rgba(172,172,64,' + f + ')');
	gStroke.addColorStop(1,'rgba(32,140,32,' + f + ')');
	// fill gradient
	var gFill = gameCtx.createLinearGradient(0.5*(gameCanvas.width + this.lb - this.rb), tb - 0.5,
		0.5*(gameCanvas.width + this.lb - this.rb), gameCanvas.height - (bb - 0.5));
	gFill.addColorStop(0,'rgba(140,32,32,' + f*0.5 + ')');
	gFill.addColorStop(0.5, 'rgba(172,172,64,' + f*0.5 + ')');
	gFill.addColorStop(1,'rgba(32,140,32,' + f*0.5 + ')');
	return {
		stroke: gStroke,
		fill: gFill
	}
}

/**************************************************************************************************************\
██████╗ ██████╗  █████╗ ██╗    ██╗     ██████╗  █████╗ ███╗   ███╗███████╗    ██╗    ██╗ █████╗ ██╗     ██╗     
██╔══██╗██╔══██╗██╔══██╗██║    ██║    ██╔════╝ ██╔══██╗████╗ ████║██╔════╝    ██║    ██║██╔══██╗██║     ██║     
██║  ██║██████╔╝███████║██║ █╗ ██║    ██║  ███╗███████║██╔████╔██║█████╗      ██║ █╗ ██║███████║██║     ██║     
██║  ██║██╔══██╗██╔══██║██║███╗██║    ██║   ██║██╔══██║██║╚██╔╝██║██╔══╝      ██║███╗██║██╔══██║██║     ██║     
██████╔╝██║  ██║██║  ██║╚███╔███╔╝    ╚██████╔╝██║  ██║██║ ╚═╝ ██║███████╗    ╚███╔███╔╝██║  ██║███████╗███████╗
╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝ ╚══╝╚══╝      ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝╚══════╝     ╚══╝╚══╝ ╚═╝  ╚═╝╚══════╝╚══════╝
\**************************************************************************************************************/

// circular corners
levelScreen.drawGameWallRounded = function (gStroke, gFill) {
	// width of outside game wall border
	var edgeWidth = this.edgeWidth;
	gameCtx.lineWidth = 2.0;
	gameCtx.strokeStyle = gStroke;
	gameCtx.fillStyle = gFill;

	// width of border between game wall and canvas wall
	var tb = this.tb - gameCtx.lineWidth/2.0;
	var bb = this.bb - gameCtx.lineWidth/2.0;
	var lb = this.lb - gameCtx.lineWidth/2.0;
	var rb = this.rb - gameCtx.lineWidth/2.0;

	// wall dimensions
	var vMiddle = 0.5*(gameCanvas.height + tb - bb);
	var top = tb;
	var bottom = gameCanvas.height - bb;
	var left = lb;
	var right = gameCanvas.width - rb;
	var r = this.cornerRadius - gameCtx.lineWidth/2.0;

	// goal dimensions
	var bottomEdge = gameCanvas.height - edgeWidth;
	var hMiddle = 0.5*(gameCanvas.width + lb - rb);
	var goalWidth = this.goalWidth;
	var goalLeft = hMiddle - 0.5*goalWidth; // where left edge of goal starts on bottom wall
	var goalRight = hMiddle + 0.5*goalWidth;
	var rg = this.goalRadius - gameCtx.lineWidth/2.0; // radius of circle; note that the wall is the outer edge of the line
	var b = bb - edgeWidth; // actual width of bottom buffer

	var goalBottom = bottomEdge; // bottom y of goal circles
	var goalLeftEdge = goalLeft + rg; // x of inner edge on left corner of goal; left edge is at (goalLeftEdge, goalBottom)
	var goalRightEdge = goalRight - rg;
	var theta = 0;
	if (rg > b) { // quarter circle is incomplete
		var Rcos = Math.sqrt(2*b*rg - b*b);
		goalLeftEdge = goalLeft + Rcos;
		goalRightEdge = goalRight - Rcos;
		theta = Math.acos(Rcos/rg);
	} else if (rg < b) { // quarter circle is complete and there's still some goal left to make using straight lines
		goalBottom = bottom + rg;
	}
	var goalCenter = bottom + rg; // y of center of goal circles

	// middle line
	gameCtx.beginPath();
	gameCtx.moveTo(left, vMiddle);
	gameCtx.lineTo(right, vMiddle);
	gameCtx.stroke();

	// bottom line
	gameCtx.beginPath();
	gameCtx.moveTo(goalLeft, bottom);
	gameCtx.lineTo(goalRight, bottom);
	gameCtx.stroke();

	// note that y is flipped from standard math, so pi/2, usually the +y axis, is actually *down*, not up
	// start with bottom left, from the goal, and go around the board to the other side of the goal
	gameCtx.beginPath();
	gameCtx.moveTo(goalLeftEdge, bottomEdge);
	if (rg < b) gameCtx.lineTo(goalLeftEdge, goalBottom);
	gameCtx.arc(goalLeft, goalCenter, rg, 2*Math.PI - theta, 1.5*Math.PI, true);
	gameCtx.lineTo(left + r, bottom);
	gameCtx.arc(left + r, bottom - r, r, 0.5*Math.PI, Math.PI, false);
	gameCtx.lineTo(left, top + r);
	gameCtx.arc(left + r, top + r, r, Math.PI, 1.5*Math.PI, false);
	gameCtx.lineTo(right - r, top);
	gameCtx.arc(right - r, top + r, r, 1.5*Math.PI, 0, false);
	gameCtx.lineTo(right, bottom - r);
	gameCtx.arc(right - r, bottom - r, r, 0, 0.5*Math.PI, false);
	gameCtx.lineTo(goalRight, bottom);
	gameCtx.arc(goalRight, goalCenter, rg, 1.5*Math.PI, Math.PI + theta, true);
	if (rg < b) gameCtx.lineTo(goalRightEdge, bottomEdge);
	gameCtx.stroke();

	// outer edge
	gameCtx.lineTo(gameCanvas.width - edgeWidth, bottomEdge);
	gameCtx.lineTo(gameCanvas.width - edgeWidth, edgeWidth);
	gameCtx.lineTo(edgeWidth, edgeWidth);
	gameCtx.lineTo(edgeWidth, gameCanvas.height - edgeWidth);
	gameCtx.lineTo(goalLeftEdge, bottomEdge);
	gameCtx.fill();
}

levelScreen.drawGameWallClipped = function (gStroke, gFill) {
	// width of outside game wall border
	var edgeWidth = this.edgeWidth;
	gameCtx.lineWidth = 2.0;
	gameCtx.strokeStyle = gStroke;
	gameCtx.fillStyle = gFill;

	// width of border between game wall and canvas wall
	var tb = this.tb - gameCtx.lineWidth/2.0;
	var bb = this.bb - gameCtx.lineWidth/2.0;
	var lb = this.lb - gameCtx.lineWidth/2.0;
	var rb = this.rb - gameCtx.lineWidth/2.0;

	// wall dimensions
	var vMiddle = 0.5*(gameCanvas.height + tb - bb);
	var top = tb;
	var bottom = gameCanvas.height - bb;
	var left = lb;
	var right = gameCanvas.width - rb;
	var r = this.cornerRadius - gameCtx.lineWidth/2.0; // not actually a radius, but it fulfills the same purpose

	// goal dimensions
	var bottomEdge = gameCanvas.height - edgeWidth;
	var hMiddle = 0.5*(gameCanvas.width + lb - rb);
	var goalWidth = this.goalWidth;
	var goalLeft = hMiddle - 0.5*goalWidth; // where left edge of goal starts on bottom wall
	var goalRight = hMiddle + 0.5*goalWidth;
	var rg = this.goalRadius - gameCtx.lineWidth/2.0; // radius of circle; note that the wall is the outer edge of the line
	var b = bb - edgeWidth; // actual width of bottom buffer

	var goalBottom = bottomEdge; // bottom y of goal lines
	var goalLeftEdge = goalLeft + rg; // x of inner edge on left corner of goal; left edge is at (goalLeftEdge, goalBottom)
	var goalRightEdge = goalRight - rg;
	if (rg > b) {
		goalLeftEdge = goalLeft + b;
		goalRightEdge = goalRight - b;
	} else if (rg < b) {
		goalBottom = bottom + rg;
	}

	// middle line
	gameCtx.beginPath();
	gameCtx.moveTo(left, vMiddle);
	gameCtx.lineTo(right, vMiddle);
	gameCtx.stroke();

	// bottom line
	gameCtx.beginPath();
	gameCtx.moveTo(goalLeft, bottom);
	gameCtx.lineTo(goalRight, bottom);
	gameCtx.stroke();

	// start with bottom left, from the goal, and go around the board to the other side of the goal
	gameCtx.beginPath();
	gameCtx.moveTo(goalLeftEdge, bottomEdge);
	if (rg < b) gameCtx.lineTo(goalLeftEdge, goalBottom);
	gameCtx.lineTo(goalLeft, bottom);
	gameCtx.lineTo(left + r, bottom);
	gameCtx.lineTo(left, bottom - r);
	gameCtx.lineTo(left, top + r);
	gameCtx.lineTo(left + r, top);
	gameCtx.lineTo(right - r, top);
	gameCtx.lineTo(right, top + r);
	gameCtx.lineTo(right, bottom - r);
	gameCtx.lineTo(right - r, bottom);
	gameCtx.lineTo(goalRight, bottom);
	gameCtx.lineTo(goalRightEdge, goalBottom);
	if (rg < b) gameCtx.lineTo(goalRightEdge, bottomEdge);
	gameCtx.stroke();

	// outer edge
	gameCtx.lineTo(gameCanvas.width - edgeWidth, bottomEdge);
	gameCtx.lineTo(gameCanvas.width - edgeWidth, edgeWidth);
	gameCtx.lineTo(edgeWidth, edgeWidth);
	gameCtx.lineTo(edgeWidth, gameCanvas.height - edgeWidth);
	gameCtx.lineTo(goalLeftEdge, bottomEdge);
	gameCtx.fill();
}

/*********************************************************************\
██╗███╗   ██╗██╗████████╗    ██╗    ██╗ █████╗ ██╗     ██╗     ███████╗
██║████╗  ██║██║╚══██╔══╝    ██║    ██║██╔══██╗██║     ██║     ██╔════╝
██║██╔██╗ ██║██║   ██║       ██║ █╗ ██║███████║██║     ██║     ███████╗
██║██║╚██╗██║██║   ██║       ██║███╗██║██╔══██║██║     ██║     ╚════██║
██║██║ ╚████║██║   ██║       ╚███╔███╔╝██║  ██║███████╗███████╗███████║
╚═╝╚═╝  ╚═══╝╚═╝   ╚═╝        ╚══╝╚══╝ ╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝
\*********************************************************************/

levelScreen.initWallsRounded = function () {
	// build up walls
	var goalLeft = (gameCanvas.width + this.lb - this.rb - this.goalWidth)*0.5;
	var goalRight = (gameCanvas.width + this.lb - this.rb + this.goalWidth)*0.5;

	// create wall objects for collisions
	// walls actually extend into the rounded corners
	// left wall
	var wallL = new Wall(this.lb, this.tb, this.lb, gameCanvas.height - this.bb);
	// right wall
	var wallR = new Wall(gameCanvas.width - this.rb, this.tb, gameCanvas.width - this.rb, gameCanvas.height - this.bb);
	// top wall
	var wallT = new Wall(this.lb, this.tb, gameCanvas.width - this.rb, this.tb);
	// bottom wall left of the goal
	var wallLB = new Wall(this.lb, gameCanvas.height - this.bb, goalLeft, gameCanvas.height - this.bb);
	// bottom wall right of the goal
	var wallRB = new Wall(goalRight, gameCanvas.height - this.bb, gameCanvas.width - this.rb, gameCanvas.height - this.bb);
	// goal line (ball can pass, paddle cannot)
	var wallG = new Wall(goalLeft, gameCanvas.height - this.bb, goalRight, gameCanvas.height - this.bb);
	wallG.passable = {CueBall: true};
	// middle line (ball can pass, paddle cannot)
	var wallS = new Wall(this.lb, 0.5*(gameCanvas.height + this.tb - this.bb),
		gameCanvas.width - this.rb, 0.5*(gameCanvas.height + this.tb - this.bb));
	wallS.passable = {CueBall: true};
	// circular corners
	// top left corner
	var wallTL = new ArcWall(this.lb + this.cornerRadius, this.tb + this.cornerRadius, this.cornerRadius,
		1.5*Math.PI, Math.PI, true);
	// top right corner
	var wallTR = new ArcWall(gameCanvas.width - this.rb - this.cornerRadius, this.tb + this.cornerRadius, this.cornerRadius,
		0, 1.5*Math.PI, true);
	// bottom right corner
	var wallBR = new ArcWall(gameCanvas.width - this.rb - this.cornerRadius, gameCanvas.height - this.bb - this.cornerRadius,
		this.cornerRadius, 0.5*Math.PI, 0, true);
	// bottom left corner
	var wallBL = new ArcWall(this.lb + this.cornerRadius, gameCanvas.height - this.bb - this.cornerRadius, this.cornerRadius,
		Math.PI, 0.5*Math.PI, true);
	var wallGL, wallGR, wallHL, wallHR, wallEL, wallER;
	if (this.goalRadius <= this.bb) {
		// left corner of goal
		wallGL = new ArcWall(goalLeft, gameCanvas.height - this.bb + this.goalRadius, this.goalRadius, 0, 1.5*Math.PI, true);
		// right corner of goal
		wallGR = new ArcWall(goalRight, gameCanvas.height - this.bb + this.goalRadius, this.goalRadius, 1.5*Math.PI, Math.PI, true);
		// left and right sides of goal corridor -- out of view but necessary to prevent glitches
		wallHL = new Wall(goalLeft + this.goalRadius, gameCanvas.height - this.bb + this.goalRadius, goalLeft + this.goalRadius, gameCanvas.height + 500);
		wallHR = new Wall(goalRight - this.goalRadius, gameCanvas.height - this.bb + this.goalRadius, goalRight - this.goalRadius, gameCanvas.height + 500);
		wallEL = undefined;
		wallER = undefined;
	} else {
		// the goal circles are too big for the buffer, so they have to be partial circles, but then they have to smoothly connect to the verticals
		var Rcos = Math.sqrt(2*this.bb*this.goalRadius - this.bb*this.bb);
		var rcos = Rcos*this.extraRadius/this.goalRadius;
		var theta = Math.acos(Rcos/this.goalRadius);
		var rsin = this.extraRadius*(this.goalRadius - this.bb)/(this.goalRadius);
		// left corner of goal
		wallGL = new ArcWall(goalLeft, gameCanvas.height - this.bb + this.goalRadius, this.goalRadius, 2*Math.PI - theta, 1.5*Math.PI, true);
		// right corner of goal
		wallGR = new ArcWall(goalRight, gameCanvas.height - this.bb + this.goalRadius, this.goalRadius, 1.5*Math.PI, Math.PI - theta, true);
		// these circles don't go from horizontal to vertical, so we're going to add small circles with this.extraRadius to get there smoothly
		wallEL = new ArcWall(goalLeft + Rcos - rcos, gameCanvas.height + rsin, this.extraRadius, 0, 2*Math.PI - theta, true);
		wallER = new ArcWall(goalRight - Rcos + rcos, gameCanvas.height + rsin, this.extraRadius, Math.PI - theta, Math.PI, true);
		wallHL = new Wall(goalLeft + Rcos - rcos + this.extraRadius, gameCanvas.height + rsin, goalLeft + Rcos - rcos + this.extraRadius, gameCanvas.height + 500);
		wallHR = new Wall(goalRight - Rcos + rcos - this.extraRadius, gameCanvas.height + rsin, goalRight - Rcos + rcos - this.extraRadius, gameCanvas.height + 500);
	}
	// add walls to list for collisions
	this.walls = [wallL, wallR, wallT, wallLB, wallRB, wallS, wallG, wallTL, wallTR, wallBR, wallBL, wallGL, wallGR, wallHL, wallHR];
	if (wallEL !== undefined) this.walls.push(wallEL);
	if (wallER !== undefined) this.walls.push(wallER);
}

levelScreen.initWallsClipped = function () {
	// build up walls
	var goalLeft = (gameCanvas.width + this.lb - this.rb - this.goalWidth)*0.5;
	var goalRight = (gameCanvas.width + this.lb - this.rb + this.goalWidth)*0.5;

	// create wall objects for collisions
	// left wall
	var wallL = new Wall(this.lb, this.tb, this.lb, gameCanvas.height - this.bb);
	// right wall
	var wallR = new Wall(gameCanvas.width - this.rb, this.tb, gameCanvas.width - this.rb, gameCanvas.height - this.bb);
	// top wall
	var wallT = new Wall(this.lb, this.tb, gameCanvas.width - this.rb, this.tb);
	// bottom wall left of the goal
	var wallLB = new Wall(this.lb, gameCanvas.height - this.bb, goalLeft, gameCanvas.height - this.bb);
	// bottom wall right of the goal
	var wallRB = new Wall(goalRight, gameCanvas.height - this.bb, gameCanvas.width - this.rb, gameCanvas.height - this.bb);
	// goal line (ball can pass, paddle cannot)
	var wallG = new Wall(goalLeft, gameCanvas.height - this.bb, goalRight, gameCanvas.height - this.bb);
	wallG.passable = {CueBall: true};
	// middle line (ball can pass, paddle cannot)
	var wallS = new Wall(this.lb, 0.5*(gameCanvas.height + this.tb - this.bb),
		gameCanvas.width - this.rb, 0.5*(gameCanvas.height + this.tb - this.bb));
	wallS.passable = {CueBall: true};
	// clipped corners
	var wallTL = new Wall(this.lb, this.tb + this.cornerRadius, this.lb + this.cornerRadius, this.tb);
	var wallTR = new Wall(gameCanvas.width - this.rb, this.tb + this.cornerRadius, gameCanvas.width - this.rb - this.cornerRadius, this.tb);
	var wallBL = new Wall(this.lb, gameCanvas.height - this.bb - this.cornerRadius, this.lb + this.cornerRadius, gameCanvas.height - this.bb);
	var wallBR = new Wall(gameCanvas.width - this.rb, gameCanvas.height - this.bb - this.cornerRadius, gameCanvas.width - this.rb - this.cornerRadius, gameCanvas.height - this.bb);

	// goal walls
	var rEff = this.goalRadius;
	if (this.goalRadius > this.bb) rEff = this.bb;
	var wallGL = new Wall(goalLeft, gameCanvas.height - this.bb, goalLeft + rEff, gameCanvas.height - this.bb + rEff);
	wallGL.open = false; // collisions on the corners
	var wallGR = new Wall(goalRight, gameCanvas.height - this.bb, goalRight - rEff, gameCanvas.height - this.bb + rEff);
	wallGL.open = false;
	var wallHL = new Wall(goalLeft + rEff, gameCanvas.height - this.bb + rEff, goalLeft + rEff, gameCanvas.height + 500);
	var wallHR = new Wall(goalRight - rEff, gameCanvas.height - this.bb + rEff, goalRight - rEff, gameCanvas.height + 500);

	// add walls to list for collisions
	this.walls = [wallL, wallR, wallT, wallLB, wallRB, wallS, wallG, wallTL, wallTR, wallBR, wallBL, wallGL, wallGR, wallHL, wallHR];
}

/**********************************************************************\
██╗███╗   ██╗██╗████████╗    ██████╗ ██████╗ ██╗ ██████╗██╗  ██╗███████╗
██║████╗  ██║██║╚══██╔══╝    ██╔══██╗██╔══██╗██║██╔════╝██║ ██╔╝██╔════╝
██║██╔██╗ ██║██║   ██║       ██████╔╝██████╔╝██║██║     █████╔╝ ███████╗
██║██║╚██╗██║██║   ██║       ██╔══██╗██╔══██╗██║██║     ██╔═██╗ ╚════██║
██║██║ ╚████║██║   ██║       ██████╔╝██║  ██║██║╚██████╗██║  ██╗███████║
╚═╝╚═╝  ╚═══╝╚═╝   ╚═╝       ╚═════╝ ╚═╝  ╚═╝╚═╝ ╚═════╝╚═╝  ╚═╝╚══════╝
\**********************************************************************/

levelScreen.initBricks1 = function () {
	for (var i = 0; i < 10; i++) {
		for (var j = 0; j < 6; j++) {
			var brick = new SimpleBrick(54 + i*(4 + (gameCanvas.width - 144.0)/10.0),
										150 + 24*j,
										(gameCanvas.width - 144.0)/10.0,
										20,
										8000000);
			brick.HP = (brick.HP * (7 - j))/7;
			brick.update(); // make sure the color on the brick is correct
			this.bricks.push(brick);
		}
	}
};

levelScreen.initBricks2 = function () {
	for (var i = 0; i < 10; i++) {
		for (var j = 0; j < 6; j++) {
			var brick = new SimpleBrick(54 + i*(4 + (gameCanvas.width - 144.0)/10.0),
										150 + 24*j,
										(gameCanvas.width - 144.0)/10.0,
										20,
										8000000);
			var c = randomColor();
			brick.fillR = Math.floor(c.r/2.0);
			brick.fillG = Math.floor(c.g/2.0);
			brick.fillB = Math.floor(c.b/2.0);
			brick.strokeR = 2*brick.fillR;
			brick.strokeG = 2*brick.fillG;
			brick.strokeB = 2*brick.fillB;
			if (j % 3 == 2) brick.frequency = 22*C1;
			else if (j % 3 == 0) brick.frequency = 18*C1;
			this.bricks.push(brick);
		}
	}
};

/***************************************************************************\
██╗███╗   ██╗██╗████████╗    ██████╗  █████╗ ██████╗ ██████╗ ██╗     ███████╗
██║████╗  ██║██║╚══██╔══╝    ██╔══██╗██╔══██╗██╔══██╗██╔══██╗██║     ██╔════╝
██║██╔██╗ ██║██║   ██║       ██████╔╝███████║██║  ██║██║  ██║██║     █████╗  
██║██║╚██╗██║██║   ██║       ██╔═══╝ ██╔══██║██║  ██║██║  ██║██║     ██╔══╝  
██║██║ ╚████║██║   ██║       ██║     ██║  ██║██████╔╝██████╔╝███████╗███████╗
╚═╝╚═╝  ╚═══╝╚═╝   ╚═╝       ╚═╝     ╚═╝  ╚═╝╚═════╝ ╚═════╝ ╚══════╝╚══════╝

 █████╗ ███╗   ██╗██████╗     ██████╗  █████╗ ██╗     ██╗     
██╔══██╗████╗  ██║██╔══██╗    ██╔══██╗██╔══██╗██║     ██║     
███████║██╔██╗ ██║██║  ██║    ██████╔╝███████║██║     ██║     
██╔══██║██║╚██╗██║██║  ██║    ██╔══██╗██╔══██║██║     ██║     
██║  ██║██║ ╚████║██████╔╝    ██████╔╝██║  ██║███████╗███████╗
╚═╝  ╚═╝╚═╝  ╚═══╝╚═════╝     ╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝
\***************************************************************************/

levelScreen.initPaddleAndBallA = function () {
	// could be level-dependent
	gameCtx.lineWidth = 2;
	var tb = this.tb - gameCtx.lineWidth/2.0;
	var bb = this.bb - gameCtx.lineWidth/2.0;
	var lb = this.lb - gameCtx.lineWidth/2.0;
	var rb = this.rb - gameCtx.lineWidth/2.0;
	var paddle = new PlayerPaddle((gameCanvas.width + lb - rb)*0.5, (gameCanvas.height + tb - bb)*(5.0/6.0), 50);
	paddle.capturing = true;
	this.paddle = paddle;
	var ball = new CueBall(gameCanvas.width*0.5, gameCanvas.height*(5.0/6.0), 0, 0, 15);
	ball.captured = paddle;
	this.balls.push(ball);
};

/**********************************************\
███████╗███╗   ██╗██████╗ ██╗███╗   ██╗ ██████╗ 
██╔════╝████╗  ██║██╔══██╗██║████╗  ██║██╔════╝ 
█████╗  ██╔██╗ ██║██║  ██║██║██╔██╗ ██║██║  ███╗
██╔══╝  ██║╚██╗██║██║  ██║██║██║╚██╗██║██║   ██║
███████╗██║ ╚████║██████╔╝██║██║ ╚████║╚██████╔╝
╚══════╝╚═╝  ╚═══╝╚═════╝ ╚═╝╚═╝  ╚═══╝ ╚═════╝ 
\**********************************************/

endingScreen = {
	// basics
	text: undefined,
	endingType: undefined,
	
	// animation
	fader: undefined,
	outlineFader: undefined
};

endingScreen.init = function () {
	gameState.ending = true;
	this.fader = new Fader(1, 2, 3);
	this.fader.start();
	this.outlineFader = new Fader(0, 5, 2);
}

endingScreen.gameWon = function () {
	this.init();
	this.text = 'Congratulations!';
	this.endingType = 'gameWon';
}

endingScreen.gameOver = function () {
	this.init();
	this.text = 'GAME OVER';
	this.endingType = 'gameOver';
}

endingScreen.update = function () {
	this.fader.update();
	if (this.outlineFader.mode == 'active') this.outlineFader.update();
	if (this.fader.fadeMode == 'wait' && this.outlineFader.mode == 'inactive' && this.endingType == 'gameOver') this.outlineFader.start();
	if (this.outlineFader.mode == 'done' || (this.endingType == 'gameWon' && this.fader.mode == 'done')) this.end();
}

endingScreen.draw = function () {
	this.drawBackground();
	this.drawOutline();
	this.drawTitle();
}

endingScreen.drawBackground = function () {
	if (this.fader.fadeParameter < 1) {
		gameCtx.fillStyle = '#1E1E1E';
		gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
	}
	if (this.endingType == 'gameOver' && this.fader.fadeMode != 'fadeIn') gameCtx.fillStyle = 'rgba(30,0,0,' + this.fader.fadeParameter + ')';
	else  gameCtx.fillStyle = 'rgba(0,0,0,' + this.fader.fadeParameter + ')';
	gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
};

endingScreen.drawOutline = function () {
	if (this.endingType == 'gameOver' && this.fader.fadeMode != 'fadeIn') {
		drawOutline('rgba(30,0,0,' + this.fader.fadeParameter + ')','rgba(255,64,64,' + this.fader.fadeParameter + ')');
	} else drawOutline('rgba(0,0,30,' + this.fader.fadeParameter + ')','rgba(64,64,255,' + this.fader.fadeParameter + ')');
};

endingScreen.drawTitle = function () {
	if (this.endingType == 'gameOver' && this.fader.fadeMode != 'fadeIn') {
		gameCtx.fillStyle = 'rgba(128, 0, 0, ' + this.fader.fadeParameter + ')';
	} else gameCtx.fillStyle = 'rgba(237, 237, 237, ' + this.fader.fadeParameter + ')';
	if (this.endingType == 'gameOver') gameCtx.font = '120px serif';
	else gameCtx.font = '72px serif';
	var textWidth = gameCtx.measureText(this.text).width;
	gameCtx.fillText(this.text, gameCanvas.width*0.5 - textWidth*0.5, gameCanvas.height*0.5 + 18);
	if (this.endingType == 'gameOver' && this.fader.fadeMode != 'fadeIn') {
		gameCtx.strokeStyle = 'rgba(0,0,0,' + this.outlineFader.fadeParameter + ')';
		gameCtx.lineWidth = 3;
		gameCtx.strokeText(this.text, gameCanvas.width*0.5 - textWidth*0.5, gameCanvas.height*0.5 + 18);
	}
}

endingScreen.end = function () {
	this.fader = undefined;
	this.outlineFader = undefined;
	gameState.ending = false;
	gameState.title = true;
	titleScreen.initTitle();
}

/**************************************\
███████╗ █████╗ ██████╗ ███████╗██████╗ 
██╔════╝██╔══██╗██╔══██╗██╔════╝██╔══██╗
█████╗  ███████║██║  ██║█████╗  ██████╔╝
██╔══╝  ██╔══██║██║  ██║██╔══╝  ██╔══██╗
██║     ██║  ██║██████╔╝███████╗██║  ██║
╚═╝     ╚═╝  ╚═╝╚═════╝ ╚══════╝╚═╝  ╚═╝
\**************************************/

// timer for fading; read the fadeParameter for current strength of fade
// to use, make sure to call the start() method
// default formulas for fading are r^2 and (1 - r)^2
function Fader(fadeIn, wait, fadeOut) {
	if (arguments.length <= 1) { // fades in and leaves it
		fadeIn = fadeIn || 0.0;
		this.type = 'inFader';
		this.fadeIn = fadeIn;
		this.fadeInFrames = fadeIn * 1000.0 / globalOptions.mspf;
	} else { // fades in and out
		if (arguments.length == 2) {
			fadeOut = wait;
			wait = 0.0;
		}
		this.type = 'fader';
		this.fadeIn = fadeIn;
		this.wait = wait;
		this.waitFade = 1.0;
		this.fadeOut = fadeOut;
		this.fadeInFrames = fadeIn * 1000.0 / globalOptions.mspf;
		this.waitFrames = wait * 1000.0 / globalOptions.mspf;
		this.fadeOutFrames = fadeOut * 1000.0 / globalOptions.mspf;
	}
	this.frame = 0;
	this.inverted = false;
	if (fadeIn > 0) this.fadeParameter = 0;
	else this.fadeParameter = 1; // fading has already happened
	this.mode = 'inactive';
	this.fadeMode = 'fadeIn';
	if (fadeIn == 0) {
		this.fadeMode = 'wait';
		if (wait == 0) this.fadeMode = 'fadeOut';
	}
	this.fadeInFormula = 'quadratic'; // default formula for calculating fade in parameter
	this.fadeOutFormula = 'quadraticDec'; // default formula for calculating fade out parameter
}

Fader.prototype.update = function () {
	if (this.mode != 'active') return;
	else if (this.fadeMode == 'fadeIn') {
		if (this.frame > this.fadeInFrames) {
			if (this.type == 'fader') {
				this.fadeMode = 'wait';
				this.frame = 0;
			} else if (this.type == 'inFader') {
				this.mode = 'done';
			}
			this.fadeParameter = this.waitFade;
		} else {
			this.fadeParameter = this.calculateParameter(this.frame, this.fadeInFrames, this.fadeInFormula);
			this.frame++;
		}
	} else if (this.fadeMode == 'wait') {
		if (this.frame > this.waitFrames) {
			this.fadeMode = 'fadeOut';
			this.frame = 0;
		} else {
			this.frame++;
		}
	} else if (this.fadeMode == 'fadeOut') {
		if (this.frame > this.fadeOutFrames) {
			this.fadeMode = undefined;
			this.mode = 'done';
		} else {
			this.fadeParameter = this.calculateParameter(this.frame, this.fadeOutFrames, this.fadeOutFormula);
			this.frame++;
		}
	}
};

Fader.prototype.calculateParameter = function (frame, total, formula) {
	var r = this.inverted ? (1.0 - frame/total) : frame/total;
	if (formula == 'quadratic') return Math.pow(r, 2); // r^2
	else if (formula == 'quadraticDec') return Math.pow(1.0 - r, 2); // (1 - r)^2
	else if (formula == 'linear') return r; // r
	else if (formula == 'linearDec') return 1.0 - r; // 1 - r
	else {
		console.log('Fader error: Invalid formula: ' + formula);
		return 0;
	}
};

// inverts behavior of fader, though fadeIn and fadeOut are still at the start and end of the cycle, respectively
Fader.prototype.invertFader = function() {
	this.inverted = true;
	this.waitFade = 0;
};

Fader.prototype.start = function () {
	if (this.fadeMode !== undefined) this.mode = 'active'; // can't restart a fader after it's done
};

Fader.prototype.pause = function () {
	this.mode = 'paused';
};

Fader.prototype.stop = function () {
	this.mode = 'done';
};

Fader.prototype.draw = function () {}; // there's nothing to draw, but just in case this gets called somehow it shouldn't do anything

/**************************************************\
███████╗██╗   ██╗███████╗███╗   ██╗████████╗███████╗
██╔════╝██║   ██║██╔════╝████╗  ██║╚══██╔══╝██╔════╝
█████╗  ██║   ██║█████╗  ██╔██╗ ██║   ██║   ███████╗
██╔══╝  ╚██╗ ██╔╝██╔══╝  ██║╚██╗██║   ██║   ╚════██║
███████╗ ╚████╔╝ ███████╗██║ ╚████║   ██║   ███████║
╚══════╝  ╚═══╝  ╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝
\**************************************************/

function onMouseMove(e) {
	e.preventDefault();
	var canvasRect = gameCanvas.getBoundingClientRect();
	var x = e.clientX - canvasRect.left;
	var y = e.clientY - canvasRect.top;
	if (gameState.title) {
		if (e.which != 1) titleScreen.mouseDown = false;
		titleScreen.mouseMove(x,y);
	} else if (gameState.level) {
		if (e.which != 1) levelScreen.mouseDown = false;
		levelScreen.mouseMove(x,y);
	}
}

function onMouseOut(e) {
	var canvasRect = gameCanvas.getBoundingClientRect();
	var x = e.clientX - canvasRect.left;
	var y = e.clientY - canvasRect.top;
	if (gameState.title) titleScreen.mouseMove(x,y);
	else if (gameState.level) levelScreen.mouseMove(x,y);
}

function onMouseUp(e) {
	e.preventDefault();
	var canvasRect = gameCanvas.getBoundingClientRect();
	var x = e.clientX - canvasRect.left;
	var y = e.clientY - canvasRect.top;
	if (gameState.title) {
		if (0 <= x && x <= gameCanvas.width && 0 <= y && y <= gameCanvas.height) {
			titleScreen.mouseUp(x,y);
		}
		titleScreen.mouseDown = false;
	} else if (gameState.level) {
		if (0 <= x && x <= gameCanvas.width && 0 <= y && y <= gameCanvas.height) {
			levelScreen.mouseUp(x,y);
		}
		levelScreen.mouseDown = false;
	}
	//console.log('mouse up at (' + x + ',' + y + ')');
}

function onMouseDown(e) {
	e.preventDefault();
	var canvasRect = gameCanvas.getBoundingClientRect();
	var x = e.clientX - canvasRect.left;
	var y = e.clientY - canvasRect.top;
	if (gameState.title) {
		titleScreen.mouseDown = true;
	} else if (gameState.level) {
		levelScreen.mouseDown = true;
	}
	//console.log('mouse down at (' + x + ',' + y + ')');
}

function onKeyUp(e) {
	//console.log(e.which);
	if (e.which == 80) {
		gameState.paused = !gameState.paused;
	}
}

function onKeyDown(e) {
	if (e.which == 32) e.preventDefault();
}

/************************************************************************\
 ██████╗ ██████╗ ██╗     ██╗     ██╗███████╗██╗ ██████╗ ███╗   ██╗███████╗
██╔════╝██╔═══██╗██║     ██║     ██║██╔════╝██║██╔═══██╗████╗  ██║██╔════╝
██║     ██║   ██║██║     ██║     ██║███████╗██║██║   ██║██╔██╗ ██║███████╗
██║     ██║   ██║██║     ██║     ██║╚════██║██║██║   ██║██║╚██╗██║╚════██║
╚██████╗╚██████╔╝███████╗███████╗██║███████║██║╚██████╔╝██║ ╚████║███████║
 ╚═════╝ ╚═════╝ ╚══════╝╚══════╝╚═╝╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝
\************************************************************************/

// performs a collision of two GameObjects
function collide(obj1, obj2) {
	if (collisions[obj1.type] == undefined || collisions[obj1.type][obj2.type] == undefined) return;
	if (obj1.locked || obj2.locked) return; // don't collide locked objects
	collisions[obj1.type][obj2.type](obj1, obj2);
}

collisions = {
	Wall: {
		Wall: function (wall1, wall2) {}, // no collisions between walls
		PurpleBall: function (wall, ball) {
			if (!ball.isIn || wall.passable[ball.type]) return; // no wall collision until the ball is in or if wall is permeable
			var collData = wallBallCollision(wall, ball);
			if (collData) ball.damage(Math.abs(2*collData.vnf*ball.mass));
		},
		PlayerPaddle: function (wall, paddle) {
			if (wall.passable[paddle.type]) return;
			var collData = lineCircleKinematics(wall, paddle);
			if (!collData) return;
			if (collData.type == 'center on line') { // shouldn't happen
				paddle.x++;
				paddle.y++;
				return;
			} else if (collData.type == 'near collision') return;
			paddle.vx += collData.vnf*collData.u.x; // zero out normal velocity
			paddle.vy += collData.vnf*collData.u.y;
			paddle.x += collData.compression*collData.u.x;
			paddle.y += collData.compression*collData.u.y;
		},
		CueBall: function (wall, ball) {
			if (wall.passable[ball.type]) return;
			var collData = wallBallCollision(wall, ball);
			if (collData) soundBank.wallClunk(collData.dp/100000000.0);
		}
	},
	PurpleBall: {
		Wall: function (ball, wall) {
			collisions['Wall']['PurpleBall'](wall, ball);
		},
		PurpleBall: function (ball1, ball2) {
			var collData = ballBallCollision(ball1, ball2);
			if (!collData) return;
			ball1.damage(ball1.mass*(collData.v1f - collData.v1));
			ball2.damage(ball2.mass*(collData.v2f - collData.v2));
		},
		PlayerPaddle: function (ball, paddle) {
			var collData = ballPaddleCollision(ball, paddle);
		}
	},
	PlayerPaddle: {
		Wall: function (paddle, wall) {
			collisions['Wall']['PlayerPaddle'](wall, paddle);
		},
		PurpleBall: function (paddle, ball) {
			collisions['PurpleBall']['PlayerPaddle'](ball, paddle);
		},
		CueBall: function (paddle, ball) {
			if (paddle.lifted || (paddle.capturing && ball.captured == paddle)) return;
			var collData = ballPaddleCollision(ball, paddle);
			if (collData) {
				ball.lastTouched = 0;
				ball.expired = false;
				soundBank.paddleTouch(collData.dp/100000000.0);
			}
		},
		ArcWall: function (paddle, arc) {
			collisions['ArcWall']['PlayerPaddle'](arc, paddle);
		}
	},
	CueBall: {
		Wall: function (ball, wall) {
			collisions['Wall']['CueBall'](wall, ball);
		},
		PlayerPaddle: function (ball, paddle) {
			collisions['PlayerPaddle']['CueBall'](paddle, ball);
		},
		SimpleBrick: function (ball, brick) {
			var collData = circleRectangleKinematics(ball, brick);
			if (!collData) return;
			ball.x += collData.compression*collData.u.x;
			ball.y += collData.compression*collData.u.y;
			if (collData.vn > 0) return;
			ball.vx += 2*collData.vnf*collData.u.x;
			ball.vy += 2*collData.vnf*collData.u.y;
			var dp = 2*collData.vnf*ball.mass  // change in momentum of ball
			brick.damage(dp);
			brick.dying ? soundBank.brickDestroy(dp/100000000.0, brick.frequency) : soundBank.brickClunk(dp/100000000.0, brick.frequency)
		},
		ArcWall: function (ball, arc) {
			collisions['ArcWall']['CueBall'](arc, ball);
		}
	},
	SimpleBrick: {
		CueBall: function (brick, ball) {
			collisions['CueBall']['SimpleBrick'];
		}
	},
	ArcWall: {
		CueBall: function (arc, ball) {
			if (arc.passable[ball.type]) return;
			var collData = arcCircleKinematics(arc, ball, 1.0);
			if (!collData) return;
			arcBallCompression(arc, ball, collData);
			if (collData.type == "near collision") {
				ball.nearCollision = true;
			} else if (collData.type == "center on arc") {
				ball.vx *= -1;
				ball.vy *= -1; // this should never actually happen
			} else if (collData.u && collData.vn < 0) {
				ball.rigidCollision++;
				ball.rigidVector.push({x: collData.u.x, y: collData.u.y});
				ball.vx += 2*collData.vnf*collData.u.x;
				ball.vy += 2*collData.vnf*collData.u.y;
			}
			if (collData && collData.type != "near collision") {
				var dp = ball.mass*2*collData.vnf;
				soundBank.wallClunk(dp/100000000.0);
			}
		},
		PlayerPaddle: function (arc, paddle) {
			if (arc.passable[paddle.type]) return;
			var collData = arcCircleKinematics(arc, paddle, 1.0);
			arcBallCompression(arc, paddle, collData);
			if (collData && collData.u) {
				paddle.vx += collData.vnf*collData.u.x; // zero out normal velocity
				paddle.vy += collData.vnf*collData.u.y;
			}
		}
	}
};

function ballBallCollision(ball1, ball2) {
	var collData = circleCircleKinematics(ball1, ball2, 1.0);
	if (!collData) return null; // no collision
	if (collData.type == "concentric") { // same center, which is weird, but we'll just wait a frame
		// and hope nobody will notice
		ball1.vx++;
		ball2.vy--;
		return null; // collision is ignored for this frame
	}
	//if (!isNaN(ball1.vx)) console.log(collData);
	ball1.vx += (collData.v1f - collData.v1 /* - ball1.compressionReaction(collData.compression[1])*/)*collData.u.x;
	ball1.vy += (collData.v1f - collData.v1 /* - ball1.compressionReaction(collData.compression[1])*/)*collData.u.y;
	ball2.vx += (collData.v2f - collData.v2 /* + ball2.compressionReaction(collData.compression[2])*/)*collData.u.x;
	ball2.vy += (collData.v2f - collData.v2 /* + ball2.compressionReaction(collData.compression[2])*/)*collData.u.y;
	if (!ball1.rigidCollision && !ball2.rigidCollision) {
		// don't use elastic compression if the balls go too far in a frame; just decompress them as if it's rigid
		ball1.x -= collData.compression[1]*collData.u.x;
		ball1.y -= collData.compression[1]*collData.u.y;
		ball2.x += collData.compression[2]*collData.u.x;
		ball2.y += collData.compression[2]*collData.u.y;
	} else if (ball1.rigidCollision && ball2.rigidCollision) {
		// use elastic compression because there's not much more we can do without getting seriously complicated
		ball1.vx += (collData.v1f - collData.v1 - ball1.compressionReaction(collData.compression[1]))*collData.u.x;
		ball1.vy += (collData.v1f - collData.v1 - ball1.compressionReaction(collData.compression[1]))*collData.u.y;
		ball2.vx += (collData.v2f - collData.v2 + ball2.compressionReaction(collData.compression[2]))*collData.u.x;
		ball2.vy += (collData.v2f - collData.v2 + ball2.compressionReaction(collData.compression[2]))*collData.u.y;
	} else if (ball1.rigidCollision) {
		// ball 2 gets all the compression; it's not so realistic because ball 1 could slide along the compression
		// parallel vector, but it's just one frame; we can replace this if necessary
		ball2.x += collData.compression.total*collData.u.x;
		ball2.y += collData.compression.total*collData.u.y;
	} else if (ball2.rigidCollision) {
		// ball 1 gets all the compression
		ball1.x -= collData.compression.total*collData.u.x;
		ball1.y -= collData.compression.total*collData.u.y;
	}
	var dp = ball1.mass*(collData.v1f - collData.v1) + ball2.mass*(collData.v2 - collData.v2f);
	return {
		v1: collData.v1,
		v2: collData.v2,
		v1f: collData.v1f,
		v2f: collData.v2f,
		dp: dp
	};
}

// returns whatever properties are necessary for game state
function wallBallCollision(wall, ball) {
	var collData = lineCircleKinematics(wall, ball);
	if (!collData) return null;
	if (collData.type == 'center on line') {
		ball.vx++;
		ball.vy++; // nudge the ball
		return null;
	} else if (collData.type == 'near collision') {
		ball.nearCollision = true;
		return null
	}
	//var vi = distance(0,0,ball.vx,ball.vy);
	ball.vx += 2*collData.vnf*collData.u.x;
	ball.vy += 2*collData.vnf*collData.u.y;
	if (ball.rigidCollision == 0 ||
			(ball.rigidCollision == 1 &&
			ball.rigidVector[0].x*collData.u.x + ball.rigidVector[0].y*collData.u.y >= 0)) {
		ball.x += collData.compression*collData.u.x;
		ball.y += collData.compression*collData.u.y;
		ball.rigidVector.push({x: collData.u.x, y: collData.u.y});
		ball.rigidCollision++;
	} else { // fudge
		var px = collData.u.x - (collData.u.x*ball.rigidVector[0].x +
			collData.u.y*ball.rigidVector[0].y)*ball.rigidVector[0].x;
		var py = collData.u.y - (collData.u.x*ball.rigidVector[0].x +
			collData.u.y*ball.rigidVector[0].y)*ball.rigidVector[0].y;
		var p = distance(0,0,px,py);
		var compression = collData.compression*p/(collData.u.x*px + collData.u.y*py);
		ball.x += compression*px/p;
		ball.y += compression*py/p;
	}
	return {vnf: collData.vnf, dp: ball.mass*Math.abs(collData.vn - collData.vnf)};
}

function ballPaddleCollision(ball, paddle) {
	var collData = circleCircleKinematics(ball, paddle, 1.0);
	if (!collData) {
		if (ball.vx == 0 && ball.vy == 0) {
			// ball might be stuck, so nudge it a little
			for (var c = 0; c < ball.rigidVector.length; c++) {
				ball.vx += 10*ball.rigidVector[c].x;
				ball.vy += 10*ball.rigidVector[c].y;
			}
			return null;
		} else {
			return null; // no collision
		}
	}
	if (collData == "concentric") { // same center, which could happen
		ball.vx++;
		return null;
	}
	var pn = ball.mass*collData.v1; // initial momentum of ball along axis of collision
	ball.vx += (collData.v1f - collData.v1)*collData.u.x;
	ball.vy += (collData.v1f - collData.v1)*collData.u.y;
	if (ball.rigidCollision) {
		// zero out the ball's velocity normal to the rigid collision
		for (var i = 0; i < ball.rigidVector.length; i++) {
			if (ball.vx*ball.rigidVector[i].x + ball.vy*ball.rigidVector[i].y < 0) {
				ball.vx -= (ball.vx*ball.rigidVector[i].x + ball.vy*ball.rigidVector[i].y)*ball.rigidVector[i].x;
				ball.vy -= (ball.vx*ball.rigidVector[i].x + ball.vy*ball.rigidVector[i].y)*ball.rigidVector[i].y;
			}
		}
		paddle.x += collData.compression.total*collData.u.x;
		paddle.y += collData.compression.total*collData.u.y;
	} else if (!ball.nearCollision) {
		ball.x -= collData.compression.total*collData.u.x;
		ball.y -= collData.compression.total*collData.u.y;
	}
	var pnf = ball.mass*(ball.vx*collData.u.x + ball.vy*collData.u.y); // final momentum of ball along axis of collision
	return {dp: Math.abs(pn - pnf)};
}

// deals with compression for an arc collision
function arcBallCompression(arc, ball, collData) { // also works on a paddle
	if (!collData || !collData.u) return; // collData from arcCircleKinematics
	var xn = ball.x + collData.compression*collData.u.x; // new location
	var yn = ball.y + collData.compression*collData.u.y;
	if (distance(xn,yn,collData.x1,collData.y1) < ball.radius || distance(xn,yn,collData.x2,collData.y2) < ball.radius) {
		if (ball.radius == arc.radius) {
			ball.x = arc.x;
			ball.y = arc.y;
		} else if (ball.radius > arc.radius) {
			var to2 = 0.5*(arc.t2 - arc.t1);
			var s = ball.radius*Math.sqrt(1 - ((arc.radius*arc.radius)/(ball.radius*ball.radius))*Math.pow(Math.sin(to2),2)) -
				arc.radius*Math.cos(to2);
			var px = -Math.cos(0.5*(arc.t1 + arc.t2));
			var py = -Math.sin(0.5*(arc.t1 + arc.t2));
			ball.x = arc.x + s*px;
			ball.y = arc.y + s*py;
		} else { // other case is never going to happen but we might as well be careful
			ball.x = xn;
			ball.y = yn;
		}
	} else {
		ball.x = xn;
		ball.y = yn;
	}
	if (debug) {
		ball.collData = collData; // so we can inspect issues here
		if (ball.x == 740 && ball.y == 740) console.log('wall');
	}
}

/**************************************************************************\
██╗  ██╗██╗███╗   ██╗███████╗███╗   ███╗ █████╗ ████████╗██╗ ██████╗███████╗
██║ ██╔╝██║████╗  ██║██╔════╝████╗ ████║██╔══██╗╚══██╔══╝██║██╔════╝██╔════╝
█████╔╝ ██║██╔██╗ ██║█████╗  ██╔████╔██║███████║   ██║   ██║██║     ███████╗
██╔═██╗ ██║██║╚██╗██║██╔══╝  ██║╚██╔╝██║██╔══██║   ██║   ██║██║     ╚════██║
██║  ██╗██║██║ ╚████║███████╗██║ ╚═╝ ██║██║  ██║   ██║   ██║╚██████╗███████║
╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝ ╚═════╝╚══════╝
\**************************************************************************/

// returns an object of useful information regarding a circle-circle collision
// null if they don't collide
// ball1 and ball2 have properties x, y, vx, vy, radius, mass
// cR is the coefficient of restitution, 1.0 for elastic and 0.0 for inelastic
function circleCircleKinematics(ball1, ball2, cR) {
	var ds = distance(ball1.x, ball1.y, ball2.x, ball2.y);
	if (ds > ball1.radius + ball2.radius) return null; // no collision
	if (ds == 0) return {type: "concentric"};
	var compLength = ball1.radius + ball2.radius - ds;
	var compression = {
		total: compLength,
		1: compLength*ball2.radius/(ball1.radius + ball2.radius),
		2: compLength*ball1.radius/(ball1.radius + ball2.radius)
	};
	var dx = ball2.x - ball1.x;
	var dy = ball2.y - ball1.y;
	var ux = dx/ds;
	var uy = dy/ds;
	var v1 = ball1.vx*ux + ball1.vy*uy; // projection along axis of collision;
	var v2 = ball2.vx*ux + ball2.vy*uy; // v1 - v2 should be positive
	var v1f = v1; // no change if v1 - v2 is negative
	var v2f = v2;
	if (v1 - v2 > 0) {
		if (!isNaN(ball1.mass) && !isNaN(ball2.mass)) {
			v1f = (cR*ball2.mass*(v2 - v1) + ball1.mass*v1 + ball2.mass*v2)/(ball1.mass + ball2.mass);
			v2f = (cR*ball1.mass*(v1 - v2) + ball1.mass*v1 + ball2.mass*v2)/(ball1.mass + ball2.mass);
		} else if (isNaN(ball1.mass) && isNaN(ball2.mass)) {
			// no collision
		} else if (isNaN(ball1.mass)) {
			v2f = cR*(v1 - v2) + v1;
		} else {
			v1f = cR*(v2 - v1) + v2;
		}
	}
	return {
		type: "normal",
		compression: compression, // how much each ball is compressed due to discrete frames
		v1: v1, // velocity of ball 1 prior to impact along the axis of collision
		v2: v2,
		v1f: v1f, // velocity of ball 1 after impact along the axis of collision
		v2f: v2f,
		u: { // unit vector pointing from the center of ball 1 towards the center of ball 2
			x: ux,
			y: uy,
		}
	};
}

// returns an object of useful information regarding a circle-line segment collision
// null if they don't collide
function lineCircleKinematics(wall, ball) {
	var centerToLine = Math.abs((wall.A*ball.x + wall.B*ball.y + wall.C)/wall.D);
	if (centerToLine > 2*ball.radius) {
		return null;
	}
	var xColl = (wall.B*(wall.B*ball.x - wall.A*ball.y) - wall.A*wall.C)/(wall.A*wall.A + wall.B*wall.B);
	var yColl = (wall.A*(wall.A*ball.y - wall.B*ball.x) - wall.B*wall.C)/(wall.A*wall.A + wall.B*wall.B);
	if (wall.B) { // not vertical wall
		if (wall.x1 < xColl && xColl < wall.x2) { // hits the wall
		} else if (wall.open) {
			return null
		} else if (xColl <= wall.x1) {
			if (distance(wall.x1, wall.y1, ball.x, ball.y) <= 2*ball.radius) { // corner hit
				xColl = wall.x1;
				yColl = wall.y1;
			} else return null;
		} else if (wall.x2 <= xColl) {
			if (distance(wall.x2, wall.y2, ball.x, ball.y) <= 2*ball.radius) {
				xColl = wall.x2;
				yColl = wall.y2;
			} else return null;
		} else return null;
	} else { // vertical
		var ys = (wall.y1 < wall.y2) ? wall.y1 : wall.y2;
		var yl = (wall.y1 < wall.y2) ? wall.y2 : wall.y1;
		if (ys < yColl && yColl < yl) { // hits the wall
		} else if (wall.open) {
			return null;
		} else if (yColl <= ys) {
			if (distance(wall.x1, ys, ball.x, ball.y) <= 2*ball.radius) { // corner hit
				yColl = ys;
			} else return null;
		} else if (yl <= yColl) {
			if (distance(wall.x1, yl, ball.x, ball.y) <= 2*ball.radius) { // corner hit
				yColl = yl;
			} else return null;
		} else return null;
	}
	var dx = ball.x - xColl;
	var dy = ball.y - yColl;
	var ds = distance(xColl, yColl, ball.x, ball.y);
	if (ds == 0) return {type: "center on line"};
	if ((ball.lastPosition.x - xColl)*dx + (ball.lastPosition.y - yColl)*dy < 0) ds *= -1;
	var compression = ball.radius - ds;
	var ux = dx/ds; // unit vector from point of collision to center of ball
	var uy = dy/ds;
	var vn = ball.vx*ux + ball.vy*uy; // projection of ball's velocity onto the unit vector
	if (ds > ball.radius/* && vn < 0*/) {
		return {type: "near collision"};
	}
	return {
		type: "normal",
		compression: compression,
		vn: vn,
		vnf: -vn, // the ball bounces back at the same normal velocity
		u: {
			x: ux,
			y: uy
		}
	};
}

function circleRectangleKinematics(ball, brick) {
	// we'll assume stationary rectangle for the nonce
	// assume the rectangle is aligned with the axes too; we'll change this eventually
	if (distance(brick.center.x, brick.center.y, ball.x, ball.y) > brick.radius + ball.radius) {
		return null;
	}
	var collData = {};
	var tCollData = {u: {}};
	var tBall = {x: ball.x, y: ball.y}; // coordinate transformations would go here
	var tBrick = {tl: brick.tl, tr: brick.tr, br: brick.br, bl: brick.bl};
	// we'll want to do coordinate transformations
	// eight regions this ball could be in with respect to the brick
	if (tBall.y >= tBrick.br.y) { // bottom region
		if (tBrick.bl.x <= tBall.x && tBall.x <= tBrick.br.x) { // bottom side
			var ds = tBall.y - tBrick.br.y;
			if (ds > ball.radius) return null;
			tCollData.xColl = tBall.x;
			tCollData.yColl = tBrick.br.y;
			tCollData.u.x = 0.0;
			tCollData.u.y = 1.0;
			collData.compression = ball.radius - ds;
		} else if (tBall.x < tBrick.bl.x) { // bl corner
			var ds = distance(tBall.x, tBall.y, tBrick.bl.x, tBrick.bl.y);
			if (ds > ball.radius) return null;
			tCollData.xColl = tBrick.bl.x;
			tCollData.yColl = tBrick.bl.y;
			tCollData.u.x = (tBall.x - tBrick.bl.x)/ds;
			tCollData.u.y = (tBall.y - tBrick.bl.y)/ds;
			collData.compression = ball.radius - ds;
		} else if (tBall.x > tBrick.br.x) { // br corner
			var ds = distance(tBall.x, tBall.y, tBrick.br.x, tBrick.br.y);
			if (ds > ball.radius) return null;
			tCollData.xColl = tBrick.br.x;
			tCollData.yColl = tBrick.br.y;
			tCollData.u.x = (tBall.x - tBrick.br.x)/ds;
			tCollData.u.y = (tBall.y - tBrick.br.y)/ds;
			collData.compression = ball.radius - ds;
		} else return null;
	} else if (tBall.y <= tBrick.tr.y) { // top region
		if (tBrick.tl.x <= tBall.x && tBall.x <= tBrick.tr.x) { // top side
			var ds = tBrick.tr.y - tBall.y;
			if (ds > ball.radius) return null;
			tCollData.xColl = tBall.x;
			tCollData.yColl = tBrick.tr.y;
			tCollData.u.x = 0.0;
			tCollData.u.y = -1.0;
			collData.compression = ball.radius - ds;
		} else if (tBall.x < tBrick.tl.x) { // tl corner
			var ds = distance(tBall.x, tBall.y, tBrick.tl.x, tBrick.tl.y);
			if (ds > ball.radius) return null;
			tCollData.xColl = tBrick.tl.x;
			tCollData.yColl = tBrick.tl.y;
			tCollData.u.x = (tBall.x - tBrick.tl.x)/ds;
			tCollData.u.y = (tBall.y - tBrick.tl.y)/ds;
			collData.compression = ball.radius - ds;
		} else if (tBall.x > tBrick.tr.x) { // tr corner
			var ds = distance(tBall.x, tBall.y, tBrick.tr.x, tBrick.tr.y);
			if (ds > ball.radius) return null;
			tCollData.xColl = tBrick.tr.x;
			tCollData.yColl = tBrick.tr.y;
			tCollData.u.x = (tBall.x - tBrick.tr.x)/ds;
			tCollData.u.y = (tBall.y - tBrick.tr.y)/ds;
			collData.compression = ball.radius - ds;
		} else return null;
	} else if (tBall.x <= tBrick.tl.x) { // left side
		var ds = tBrick.tl.x - tBall.x;
		if (ds > ball.radius) return null;
		tCollData.xColl = tBrick.tl.x;
		tCollData.yColl = tBall.y;
		tCollData.u.x = -1.0;
		tCollData.u.y = 0.0;
		collData.compression = ball.radius - ds;
	} else if (tBall.x >= tBrick.tr.x) { // right side
		var ds = tBall.x - tBrick.tr.x;
		if (ds > ball.radius) return null;
		tCollData.xColl = tBrick.tr.x;
		tCollData.yColl = tBall.y;
		tCollData.u.x = 1.0;
		tCollData.u.y = 0.0;
		collData.compression = ball.radius - ds;
	} else return null;
	collData.xColl = tCollData.xColl; // transform the coordinates back
	collData.yColl = tCollData.yColl;
	collData.u = tCollData.u;
	collData.vn = (ball.vx*collData.u.x + ball.vy*collData.u.y);
	collData.vnf = -collData.vn;
	return collData;
}

function arcCircleKinematics(arc, ball, cR) { // yay polar coordinates
	var centerDistance = distance(arc.x, arc.y, ball.x, ball.y);
	if (centerDistance > arc.radius + 2*ball.radius) return null;
	if (centerDistance < arc.radius - 2*ball.radius) return null;
	var ballAngle = Math.atan2(ball.y - arc.y, ball.x - arc.x);
	var prevBallAngle = Math.atan2(ball.lastPosition.y - arc.y, ball.lastPosition.x - arc.x);
	var prevDistance = distance(arc.x, arc.y, ball.lastPosition.x, ball.lastPosition.y);
	var flipPassed = 1; // -1 if the ball crossed the arc
	var inRange = angleInRange(ballAngle, arc.t1, arc.t2);
	if (centerDistance == arc.radius && inRange) {
		if (angleInRange(prevBallAngle, arc.t1, arc.t2)) {
			if (prevDistance < centerDistance) centerDistance -= 0.1; // just provide the ball with a direction
			else if (prevDistance > centerDistance) centerDistance += 0.1;
		} else {
			var prevOrientation = Math.atan2(ball.lastPosition.y - ball.y, ball.lastPosition.x - ball.x);
			if (angleInRange(prevOrientation, ballAngle + 0.5*Math.PI, ballAngle + 1.5*Math.PI)) {
				centerDistance -= 0.1;
			} else centerDistance += 0.1;
		}
	}
	var xColl, yColl, ux, uy, compression;
	var type = "normal";
	var x1, x2, y1, y2; // arc endpoints; will be left undefined unless they're necessary
	if (inRange && !(centerDistance < arc.radius && ball.radius > arc.radius)) { // ball inside the sector
		if (angleInRange(prevBallAngle, arc.t1, arc.t2)) {
			if ((prevDistance > arc.radius && centerDistance < arc.radius) ||
				(prevDistance < arc.radius && centerDistance > arc.radius)) flipPassed = -1;
		}
		if (centerDistance > arc.radius) { // ball is outside arc
			if (centerDistance <= arc.radius + ball.radius) {
				xColl = arc.radius*Math.cos(ballAngle) + arc.x;
				yColl = arc.radius*Math.sin(ballAngle) + arc.y;
				ux = flipPassed*Math.cos(ballAngle);
				uy = flipPassed*Math.sin(ballAngle);
				compression = arc.radius + ball.radius - centerDistance;
				if (flipPassed == -1) compression = centerDistance - arc.radius + ball.radius;
			} else return {type: "near collision"};
		} else if (centerDistance < arc.radius) { // ball is inside arc
			if (centerDistance >= arc.radius - ball.radius) { // ball is never bigger than arc
				xColl = arc.radius*Math.cos(ballAngle) + arc.x;
				yColl = arc.radius*Math.sin(ballAngle) + arc.y;
				ux = -flipPassed*Math.cos(ballAngle);
				uy = -flipPassed*Math.sin(ballAngle);
				compression = centerDistance - arc.radius + ball.radius;
				if (flipPassed == -1) compression = arc.radius + ball.radius - centerDistance;
			} else return {type: "near collision"};
		} else return {type: "center on arc"}; // this would have happened already
	} else { // ball outside the sector or inside sector but bigger than arc
		var x1 = arc.radius*Math.cos(arc.t1) + arc.x;
		var y1 = arc.radius*Math.sin(arc.t1) + arc.y;
		var x2 = arc.radius*Math.cos(arc.t2) + arc.x;
		var y2 = arc.radius*Math.sin(arc.t2) + arc.y;
		var ds1 = distance(x1, y1, ball.x, ball.y);
		var ds2 = distance(x2, y2, ball.x, ball.y);
		if (ds1 == 0 || ds2 == 0) return {type: "center on arc"};
		if (ball.radius >= arc.radius) type = "larger ball";
		else if (arc.open) return null; // no collision with endpoints if endpoints aren't included
		if (ds1 > ball.radius && ds2 <= ball.radius) { // close to point 1
			xColl = x1;
			yColl = y1;
			ux = (ball.x - x1)/ds1;
			uy = (ball.y - y1)/ds1;
			compression = ds1 - ball.radius;
		} else if (ds1 <= ball.radius && ds2 > ball.radius) { // close to point 2
			xColl = x2;
			yColl = y2;
			ux = (ball.x - x2)/ds1;
			uy = (ball.y - y2)/ds1;
			compression = ds1 - ball.radius;
		} else if (ds1 <= ball.radius && ds2 <= ball.radius) { // close to both
			type = "recenter";
			xColl = arc.radius*Math.cos(0.5*(t1 + t2)) + arc.x;
			yColl = arc.radius*Math.sin(0.5*(t1 + t2)) + arc.y;
			ux = -Math.cos(0.5*(t1 + t2));
			uy = -Math.sin(0.5*(t1 + t2));
			compression = undefined; // compression will be ignored
		} else if (ds1 > 2*ball.radius && ds2 > 2*ball.radius) { // far from both
			return null; // no collision
		} else { // one of the distances is not a collision but close to one
			return {type: "near collision"};
		}
	}
	var vn = ball.vx*ux + ball.vy*uy;
	return {
		type: type,
		xColl: xColl,
		yColl: yColl,
		compression: compression,
		u: {x: ux, y: uy},
		vn: vn,
		vnf: -vn,
		x1: x1,
		y1: y1,
		x2: x2,
		y2: y2
	};
}

/****************************************************************************************\
 ██████╗  █████╗ ███╗   ███╗███████╗     ██████╗ ██████╗      ██╗███████╗ ██████╗████████╗
██╔════╝ ██╔══██╗████╗ ████║██╔════╝    ██╔═══██╗██╔══██╗     ██║██╔════╝██╔════╝╚══██╔══╝
██║  ███╗███████║██╔████╔██║█████╗      ██║   ██║██████╔╝     ██║█████╗  ██║        ██║   
██║   ██║██╔══██║██║╚██╔╝██║██╔══╝      ██║   ██║██╔══██╗██   ██║██╔══╝  ██║        ██║   
╚██████╔╝██║  ██║██║ ╚═╝ ██║███████╗    ╚██████╔╝██████╔╝╚█████╔╝███████╗╚██████╗   ██║   
 ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝╚══════╝     ╚═════╝ ╚═════╝  ╚════╝ ╚══════╝ ╚═════╝   ╚═╝   
\****************************************************************************************/

// useless prototype at the moment, but it prevents some generic function calls from crashing
function GameObject() {
	this.type = "GameObject";
	this.remove = false;
}

GameObject.prototype.update = function () {};

GameObject.prototype.draw = function () {};

GameObject.prototype.death = function () {};

/****************************************\
██╗    ██╗ █████╗ ██╗     ██╗     ███████╗
██║    ██║██╔══██╗██║     ██║     ██╔════╝
██║ █╗ ██║███████║██║     ██║     ███████╗
██║███╗██║██╔══██║██║     ██║     ╚════██║
╚███╔███╔╝██║  ██║███████╗███████╗███████║
 ╚══╝╚══╝ ╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝
\****************************************/

// walls are immobile and invisible; they're drawn as part of the background
// they're also 1-dimensional
// breaks if it has size 0, for now
function Wall(x1, y1, x2, y2) {
	// basics
	this.type = "Wall";
	this.open = true; // no collisions on the endpoints
	
	// definition
	if (x1 < x2 || (x1 == x2 && y1 < y2)) {
		this.x1 = x1;
		this.y1 = y1;
		this.x2 = x2;
		this.y2 = y2;
	} else {
		this.x1 = x2;
		this.y1 = y2;
		this.x2 = x1;
		this.y2 = y1;
	}
	
	// equation of the line Ax + By + C = 0
	this.A = y2 - y1;
	this.B = x1 - x2;
	this.C = x2*y1 - x1*y2;
	this.D = Math.sqrt(this.A*this.A + this.B*this.B); // used in point-line distance
	
	// game aspects
	this.passable = {}; // what types this wall has no collisions with
}
Wall.prototype = new GameObject();

/********************************************************************\
 █████╗ ██████╗  ██████╗    ██╗    ██╗ █████╗ ██╗     ██╗     ███████╗
██╔══██╗██╔══██╗██╔════╝    ██║    ██║██╔══██╗██║     ██║     ██╔════╝
███████║██████╔╝██║         ██║ █╗ ██║███████║██║     ██║     ███████╗
██╔══██║██╔══██╗██║         ██║███╗██║██╔══██║██║     ██║     ╚════██║
██║  ██║██║  ██║╚██████╗    ╚███╔███╔╝██║  ██║███████╗███████╗███████║
╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝     ╚══╝╚══╝ ╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝
\********************************************************************/

// walls in the shape of circular arcs; also invisible and need to be drawn separately, 1D
// center at (x, y), from angle t1 to t2 clockwise or counterclockwise if cc is true
// 0 is +x, pi/2 is +y, which is *down*
function ArcWall(x, y, radius, t1, t2, cc) {
	// basics
	this.type = "ArcWall";
	this.open = true; // no collisions on the endpoints
	
	// definition
	this.x = x;
	this.y = y;
	this.radius = radius;
	// the arc is always clockwise, so we'll adjust t1 and t2 if not
	if (!cc) {
		this.t1 = t1;
		this.t2 = t2;
	} else {
		this.t1 = t2;
		this.t2 = t1;
	}
	while (this.t1 < 0) this.t1 += 2*Math.PI
	while (this.t1 >= 2*Math.PI) this.t1 -= 2*Math.PI;
	while (this.t2 > this.t1) this.t2 -= 2*Math.PI;
	while (this.t2 <= this.t1) this.t2 += 2*Math.PI;
	
	// game data
	this.passable = {};
}
ArcWall.prototype = new GameObject();

/*ArcWall.prototype.draw = function () {
	gameCtx.strokeStyle = "white";
	gameCtx.beginPath();
	gameCtx.arc(this.x, this.y, this.radius, this.t1, this.t2, false);
	gameCtx.stroke();
}*/

/***************************************************************************************************\
██████╗ ██╗      █████╗ ██╗   ██╗███████╗██████╗     ██████╗  █████╗ ██████╗ ██████╗ ██╗     ███████╗
██╔══██╗██║     ██╔══██╗╚██╗ ██╔╝██╔════╝██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██╔══██╗██║     ██╔════╝
██████╔╝██║     ███████║ ╚████╔╝ █████╗  ██████╔╝    ██████╔╝███████║██║  ██║██║  ██║██║     █████╗  
██╔═══╝ ██║     ██╔══██║  ╚██╔╝  ██╔══╝  ██╔══██╗    ██╔═══╝ ██╔══██║██║  ██║██║  ██║██║     ██╔══╝  
██║     ███████╗██║  ██║   ██║   ███████╗██║  ██║    ██║     ██║  ██║██████╔╝██████╔╝███████╗███████╗
╚═╝     ╚══════╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═╝    ╚═╝     ╚═╝  ╚═╝╚═════╝ ╚═════╝ ╚══════╝╚══════╝
\***************************************************************************************************/

function PlayerPaddle(x, y, radius) {
	// basics
	this.type = "PlayerPaddle";
	this.locked = false;
	
	// definition
	this.radius = radius;
	this.x = x;
	this.y = y;
	this.vx = 0;
	this.vy = 0;
	
	// physical parameters
	this.mass = this.radius*this.radius*5; // the player's paddle is not governed by physics
	this.maxSpeed = 4800;
	this.maxDistancePerFrame = this.maxSpeed*globalOptions.mspf/1000.0;
	
	// drawing
	this.fillR = 255;
	this.fillG = 255;
	this.fillB = 255;
	this.fillA = 1;
	this.strokeR = 176;
	this.strokeG = 160;
	this.strokeB = 224;
	this.strokeA = 1;
	this.liftedFillR = 255;
	this.liftedFillG = 255;
	this.liftedFillB = 255;
	this.liftedFillA = 0.33;
	this.capturingFillR = 255;
	this.capturingFillG = 255;
	this.capturingFillB = 255;
	this.capturingFillA = 0.67;
	
	// movement
	this.moveToX = x;
	this.moveToY = y;
	this.timeForVelocityAverage = 100; // in ms
	this.nVelocityFrames = Math.floor(this.timeForVelocityAverage/globalOptions.mspf);
	this.pastLocations = [{x: x, y: y}];
	this.lastPosition = {x: x, y: y};
	this.lastVelocity = {x: 0, y: 0};
	
	// game state
	this.lifted = false;
	this.capturing = false;
}
PlayerPaddle.prototype = new GameObject();

PlayerPaddle.prototype.update = function () {
	if (this.locked) return;
	while (this.pastLocations.length >= this.nVelocityFrames) {
		this.pastLocations.shift();
	}
	this.pastLocations.push({x: this.x, y: this.y});
	this.lastPosition = {x: this.x, y: this.y};
	this.lastVelocity = {x: this.vy, y: this.vy};
	if (gameState.title) {
		this.fillA = titleScreen.fadeOutParameter;
		this.strokeA = titleScreen.fadeOutParameter;
	}
	var ds = distance(this.x, this.y, this.moveToX, this.moveToY);
	var x = this.moveToX;
	var y = this.moveToY;
	if (ds > this.maxDistancePerFrame) {
		x = this.x + (this.moveToX - this.x)*this.maxDistancePerFrame/ds;
		y = this.y + (this.moveToY - this.y)*this.maxDistancePerFrame/ds;
	}
	this.vx = (x - this.pastLocations[0].x)/(this.pastLocations.length*globalOptions.mspf/1000.0);
	this.vy = (y - this.pastLocations[0].y)/(this.pastLocations.length*globalOptions.mspf/1000.0);
	this.x = x;
	this.y = y;
}

PlayerPaddle.prototype.draw = function (f) {
	if (f === undefined) f = 1;
	if (!this.lifted && !this.capturing) {
		gameCtx.fillStyle = 'rgba(' + this.fillR + ',' + this.fillG + ',' + this.fillB + ',' +
			this.fillA*f + ')';
	} else if (this.lifted) {
		gameCtx.fillStyle = 'rgba(' + this.liftedFillR + ',' + this.liftedFillG + ',' + this.liftedFillB + ',' +
			this.liftedFillA*f + ')';
	} else {
		gameCtx.fillStyle = 'rgba(' + this.capturingFillR + ',' + this.capturingFillG + ',' + this.capturingFillB + ',' +
			this.capturingFillA*f + ')';
	}
	gameCtx.strokeStyle = 'rgba(' + this.strokeR + ',' + this.strokeG + ',' + this.strokeB + ',' +
		this.strokeA*f + ')';
	gameCtx.lineWidth = 2;
	gameCtx.beginPath();
	gameCtx.arc(this.x, this.y, this.radius, 0, 2*Math.PI, true);
	gameCtx.fill();
	gameCtx.stroke();
	if (debug) {
	 	gameCtx.font = '16px sans-serif';
		gameCtx.strokeText(Math.floor(distance(0,0,this.vx,this.vy)), this.x - 8, this.y + 6);
	}
};

PlayerPaddle.prototype.move = function (x, y) {
	this.moveToX = x;
	this.moveToY = y;
};

PlayerPaddle.prototype.capture = function (ball) {
	if (ball.type == "CueBall") {
		var ds = distance(this.x, this.y, ball.x, ball.y);
		if (ds < this.radius + ball.radius) {
			ball.capturedBy(this);
			this.capturing = true;
			soundBank.paddleCapture();
		}
	}
	this.lifted = false;
}

PlayerPaddle.prototype.reviseCapture = function (ball) {
	if (ball.type == "CueBall") {
		var ds = distance(this.x, this.y, ball.x, ball.y);
		if (ds < this.radius + ball.radius) {
			ball.capturedBy(this);
			this.capturing = true;
		} else {
			ball.captured = undefined;
		}
	}
}

/**************************************\
██████╗  █████╗ ██╗     ██╗     ███████╗
██╔══██╗██╔══██╗██║     ██║     ██╔════╝
██████╔╝███████║██║     ██║     ███████╗
██╔══██╗██╔══██║██║     ██║     ╚════██║
██████╔╝██║  ██║███████╗███████╗███████║
╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝
\**************************************/

function Ball(x, y, vx, vy, radius) {
	// basics
	this.type = "Ball";
	this.locked = false;
	
	// definition
	this.radius = radius;
	this.x = x;
	this.y = y;
	this.vx = vx;
	this.vy = vy;
	this.area = this.radius*this.radius*Math.PI;
	this.lastPosition = {x: x, y: y};
	
	// physical parameters
	this.maxSpeed = 1000.0*this.radius/globalOptions.mspf
	this.density = 1.0/Math.PI;
	this.mass = this.area * this.density;
	this.bgDrag = 0;
	this.dragMultiplierPerFrame = Math.pow(1 - this.bgDrag, globalOptions.mspf/1000.0);
	this.compressionCoefficient = 8000.0;
	this.rigidCollision = 0;
	this.rigidVector = [];
	this.nearCollision = false;
	
	// drawing -- default parameters
	this.fillR = 84;
	this.fillG = 0;
	this.fillB = 216;
	this.fillA = 1.0;
	this.strokeR = 64;
	this.strokeG = 16;
	this.strokeB = 128;
	this.strokeA = 1.0;
}
Ball.prototype = new GameObject();

Ball.prototype.update = function () {
	if (this.locked) return;
	GameObject.prototype.update.call(this);
	this.nearCollision = false;
	this.rigidCollision = 0; // reset the collision
	this.rigidVector = [];
	this.lastPosition.x = this.x;
	this.lastPosition.y = this.y;
	this.vx *= this.dragMultiplierPerFrame;
	this.vy *= this.dragMultiplierPerFrame;
	var v = distance(0,0,this.vx,this.vy);
	if (v > this.maxSpeed) {
		// console.log('Speed reduced');
		this.vx *= (this.maxSpeed/v);
		this.vy *= (this.maxSpeed/v);
	}
	this.x += this.vx * globalOptions.mspf / 1000.0;
	this.y += this.vy * globalOptions.mspf / 1000.0;
}

// change in velocity due to compression; unused
Ball.prototype.compressionReaction = function (compression) {
	return (this.compressionCoefficient*compression*compression)/(this.mass*this.mass);
}

Ball.prototype.draw = function (f) {
	if (f === undefined) f = 1;
	gameCtx.fillStyle = 'rgba(' + this.fillR + ',' + this.fillG + ',' + this.fillB + ',' + this.fillA*f + ')';
	gameCtx.strokeStyle = 'rgba(' + this.strokeR + ',' + this.strokeG + ',' + this.strokeB + ',' + this.strokeA*f + ')';
	gameCtx.lineWidth = 2;
	gameCtx.beginPath();
	gameCtx.arc(this.x, this.y, this.radius, 0, 2*Math.PI, true);
	gameCtx.fill();
	gameCtx.stroke();
	if (debug) {
		gameCtx.font = '16px sans-serif';
		gameCtx.strokeText(Math.floor(distance(0,0,this.vx,this.vy)), this.x - 8, this.y + 6);
	}
}

/***********************************************************\
 ██████╗██╗   ██╗███████╗    ██████╗  █████╗ ██╗     ██╗     
██╔════╝██║   ██║██╔════╝    ██╔══██╗██╔══██╗██║     ██║     
██║     ██║   ██║█████╗      ██████╔╝███████║██║     ██║     
██║     ██║   ██║██╔══╝      ██╔══██╗██╔══██║██║     ██║     
╚██████╗╚██████╔╝███████╗    ██████╔╝██║  ██║███████╗███████╗
 ╚═════╝ ╚═════╝ ╚══════╝    ╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝
\***********************************************************/

function CueBall(x, y, vx, vy, radius) {
	Ball.apply(this, arguments);
	// basics
	this.type = "CueBall";
	this.locked = false;
	
	// definition
	this.radius = radius;
	this.x = x;
	this.y = y;
	this.vx = vx;
	this.vy = vy;
	this.area = this.radius*this.radius*Math.PI;
	
	// physical parameters
	this.density = 20.0/Math.PI;
	this.mass = this.area * this.density;
	this.bgDrag = 0.0; // fraction of velocity lost per second
	this.dragMultiplierPerFrame = Math.pow(1 - this.bgDrag, globalOptions.mspf/1000.0);
	this.compressionCoefficient = 8000.0; // unused at the moment
	this.rigidCollision = 0; // if a rigid collision has already happened this frame
	this.rigidVector = []; // unit normal vectors of collision
	
	// drawing
	this.fillR = 255;
	this.fillG = 255;
	this.fillB = 255;
	this.fillA = 1;
	this.strokeR = 141;
	this.strokeG = 128;
	this.strokeB = 180;
	this.strokeA = 1;
	this.expiredFillR = 255;
	this.expiredFillG = 255;
	this.expiredFillB = 255;
	this.expiredFillA = 0.5;
	
	// game data
	this.captured = undefined; // becomes the paddle if the ball is captured by the paddle
	this.lastTouched = 0;
	this.expired = false; // expiration is checked by the level to prevent creation of unnecessary date objects
	this.expiration = 30000; // in ms
}
CueBall.prototype = (function (ballConstructor, cueBallConstructor) {
    function protoCreator(){
        this.constructor = cueBallConstructor.prototype.constructor
    };
    protoCreator.prototype = ballConstructor.prototype;
    return new protoCreator();
})(Ball, CueBall);

CueBall.prototype.capturedBy = function (paddle) {
	this.captured = paddle;
	//console.log('Captured!');
}

CueBall.prototype.update = function () {
	if (this.locked) return;
	if (this.captured) {
		if (!this.captured.capturing) this.captured = undefined;
		else {
			if (distance(this.captured.x, this.captured.y, this.x, this.y) > this.radius + this.captured.radius) {
				this.captured = undefined
			}
		}
	}
	if (this.captured) {
		GameObject.prototype.update.call(this);
		this.lastTouched = 0;
		this.expired = false;
		this.rigidCollision = 0; // reset the collision
		this.rigidVector = [];
		var nearCollFactor = 1;
		if (this.nearCollision) nearCollFactor = 0.5; // make sure ball doesn't tunnel
		this.nearCollision = false;
		var lastLoc = this.captured.pastLocations[this.captured.pastLocations.length - 1];
		var last2Loc = this.captured.pastLocations[this.captured.pastLocations.length - 2];
		var dx = (lastLoc.x - last2Loc.x);
		var dy = (lastLoc.y - last2Loc.y);
		var ds = distance(0,0,dx,dy);
		var v = ds*(globalOptions.mspf/1000.0);
		if (v > this.maxSpeed) {
			//console.log('reduced');
			this.x += dx*nearCollFactor*this.maxSpeed/v;
			this.y += dy*nearCollFactor*this.maxSpeed/v;
			this.vx = nearCollFactor*this.captured.lastVelocity.x*this.maxSpeed/v;
			this.vy = nearCollFactor*this.captured.lastVelocity.y*this.maxSpeed/v;
		} else {
			this.x += nearCollFactor*dx;
			this.y += nearCollFactor*dy;
			this.vx = nearCollFactor*this.captured.lastVelocity.x;
			this.vy = nearCollFactor*this.captured.lastVelocity.y;
		}
	} else {
		this.lastTouched += globalOptions.mspf;
		Ball.prototype.update.call(this);
	}
}

CueBall.prototype.draw = function (f) {
	if (f === undefined) f = 1;
	if (!this.expired) {
		gameCtx.fillStyle = 'rgba(' + this.fillR + ',' + this.fillG + ',' + this.fillB + ',' + this.fillA*f + ')';
	} else {
		gameCtx.fillStyle = 'rgba(' + this.expiredFillR + ',' + this.expiredFillG + ',' + this.expiredFillB + ',' +
			this.expiredFillA*f + ')';
	}
	gameCtx.strokeStyle = 'rgba(' + this.strokeR + ',' + this.strokeG + ',' + this.strokeB + ',' + this.strokeA*f + ')';
	gameCtx.lineWidth = 2;
	gameCtx.beginPath();
	gameCtx.arc(this.x, this.y, this.radius, 0, 2*Math.PI, true);
	gameCtx.fill();
	gameCtx.stroke();
	if (debug) {
		gameCtx.font = '16px sans-serif';
		gameCtx.strokeText(Math.floor(distance(0,0,this.vx,this.vy)), this.x - 8, this.y + 6);
	}
}

/*******************************************************************************************\
██████╗ ██╗   ██╗██████╗ ██████╗ ██╗     ███████╗    ██████╗  █████╗ ██╗     ██╗     ███████╗
██╔══██╗██║   ██║██╔══██╗██╔══██╗██║     ██╔════╝    ██╔══██╗██╔══██╗██║     ██║     ██╔════╝
██████╔╝██║   ██║██████╔╝██████╔╝██║     █████╗      ██████╔╝███████║██║     ██║     ███████╗
██╔═══╝ ██║   ██║██╔══██╗██╔═══╝ ██║     ██╔══╝      ██╔══██╗██╔══██║██║     ██║     ╚════██║
██║     ╚██████╔╝██║  ██║██║     ███████╗███████╗    ██████╔╝██║  ██║███████╗███████╗███████║
╚═╝      ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚══════╝╚══════╝    ╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝
\*******************************************************************************************/

function PurpleBall(x, y, vx, vy, radius) {
	Ball.apply(this, arguments);
	// basics
	this.type = "PurpleBall";
	this.locked = false;
	
	// definition
	this.radius = radius;
	this.x = x;
	this.y = y;
	this.vx = vx; // pixels per second
	this.vy = vy;
	this.area = this.radius*this.radius*Math.PI;
	
	// physical parameters
	this.density = 1.0/Math.PI;
	this.mass = this.area * this.density;
	this.bgDrag = .03; // fraction of velocity lost per second
	this.dragMultiplierPerFrame = Math.pow(1 - this.bgDrag, globalOptions.mspf/1000.0);
	this.compressionCoefficient = 8000.0; // unused at the moment
	this.rigidCollision = 0; // if a rigid collision has already happened this frame
	this.rigidVector = []; // unit normal vectors of collision
	
	// drawing
	this.fillR = 84;
	this.fillG = 0;
	this.fillB = 216;
	this.fillA = 1.0;
	this.strokeR = 64;
	this.strokeG = 16;
	this.strokeB = 128;
	this.strokeA = 1.0;
	
	// animation
	this.hitTime = this.radius/30.0;
	this.totalHitFrames = (this.hitTime*1000)/globalOptions.mspf;
	this.hitFrame = this.totalHitFrames;
	this.dying = false;
	this.deathTime = this.radius/60.0;
	this.totalDeathFrames = (this.deathTime*1000)/globalOptions.mspf;
	this.deathFrame = 0;
	
	// game state data
	this.maxHP = 400.0*this.mass*radius;
	this.HP = this.maxHP;
	this.isIn = false;
}
PurpleBall.prototype = (function (ballConstructor, purpleBallConstructor) {
    function protoCreator(){
        this.constructor = purpleBallConstructor.prototype.constructor
    };
    protoCreator.prototype = ballConstructor.prototype;
    return new protoCreator();
})(Ball, PurpleBall);

PurpleBall.prototype.update = function() {
	if (this.locked) return;
	if ((this.x < -2*this.radius && this.vx <= 0) ||
		(this.x > gameCanvas.width + 2*this.radius && this.vx >= 0) ||
		(this.y < -2*this.radius && this.vy <= 0) ||
		(this.y > gameCanvas.height + 2*this.radius && this.vy >= 0)) {
		this.remove = true;
	} else {
		Ball.prototype.update.call(this);
	}
	if (this.x > 5 + this.radius && this.x <gameCanvas. width - 5 - this.radius &&
		this.y > 5 + this.radius && this.y < gameCanvas.height - 5 - this.radius)
		this.isIn = true;
	if (this.hitFrame < this.totalHitFrames) this.hitFrame++;
	if (this.HP <= 0) this.dying = true;
	if (this.dying) {
		this.deathFrame++;
		if (this.deathFrame >= this.totalDeathFrames) this.remove = true;
	}
	this.fillA = (this.hitFrame/this.totalHitFrames) * (this.HP/this.maxHP) * titleScreen.fadeOutParameter;
	this.strokeA = (1 - (this.deathFrame/this.totalDeathFrames)) * titleScreen.fadeOutParameter;
};

PurpleBall.prototype.damage = function (dam) {
	this.HP -= dam;
	this.hitFrame = ((2.0*this.HP/3.0)/this.maxHP)*this.totalHitFrames;
	if (this.hitFrame < 0) this.hitFrame = 0;
	if (this.HP < 0) {
		this.HP = 0;
		this.dying = true;
	}
};

PurpleBall.prototype.death = function () {
	titleScreen.purpleBallCount--;
	while (titleScreen.purpleBallCount < titleScreen.numPurpleBalls) titleScreen.generatePurpleBall();
};

/*******************************************************************************************\
███████╗██╗███╗   ███╗██████╗ ██╗     ███████╗    ██████╗ ██████╗ ██╗ ██████╗██╗  ██╗███████╗
██╔════╝██║████╗ ████║██╔══██╗██║     ██╔════╝    ██╔══██╗██╔══██╗██║██╔════╝██║ ██╔╝██╔════╝
███████╗██║██╔████╔██║██████╔╝██║     █████╗      ██████╔╝██████╔╝██║██║     █████╔╝ ███████╗
╚════██║██║██║╚██╔╝██║██╔═══╝ ██║     ██╔══╝      ██╔══██╗██╔══██╗██║██║     ██╔═██╗ ╚════██║
███████║██║██║ ╚═╝ ██║██║     ███████╗███████╗    ██████╔╝██║  ██║██║╚██████╗██║  ██╗███████║
╚══════╝╚═╝╚═╝     ╚═╝╚═╝     ╚══════╝╚══════╝    ╚═════╝ ╚═╝  ╚═╝╚═╝ ╚═════╝╚═╝  ╚═╝╚══════╝
\*******************************************************************************************/

function SimpleBrick(x, y, w, h, HP) {
	// basics
	this.type = 'SimpleBrick';
	this.locked = false;
	
	// definition
	this.tl = {x: x, y: y};
	this.tr = {x: x + w, y: y};
	this.br = {x: x + w, y: y + h};
	this.bl = {x: x, y: y + h};
	this.center = {x: x + 0.5*w, y: y + 0.5*h};
	this.w = w;
	this.h = h;
	this.vx = 0;
	this.vy = 0;
	this.area = w*h;
	this.radius = distance(this.center.x, this.center.y, this.tl.x, this.tl.y);
	
	// drawing
	this.fillR = 140;
	this.fillG = 32;
	this.fillB = 32;
	this.fillA = 1.0;
	this.strokeR = 255;
	this.strokeG = 64;
	this.strokeB = 64;
	this.strokeA = 1.0;
	
	// animation
	this.hitTime = this.area/3000.0;
	this.totalHitFrames = (this.hitTime*1000)/globalOptions.mspf;
	this.hitFrame = this.totalHitFrames;
	this.dying = false;
	this.deathTime = this.area/6000.0;
	this.totalDeathFrames = (this.deathTime*1000)/globalOptions.mspf;
	this.deathFrame = 0;

	// sound
	this.frequency = 20*C1;
	
	// game
	this.maxHP = HP;
	this.HP = HP;
}
SimpleBrick.prototype = new GameObject();

SimpleBrick.prototype.update = function () {
	if (this.locked) return;
	GameObject.prototype.update.call(this);
	if (this.hitFrame < this.totalHitFrames) this.hitFrame++;
	if (this.HP <= 0) {
		this.dying = true;
		this.HP = 0;
	}
	if (this.dying) {
		this.deathFrame++;
		if (this.deathFrame >= this.totalDeathFrames) this.remove = true;
	}
	this.fillA = (this.hitFrame/this.totalHitFrames) * (this.HP/this.maxHP);
	this.strokeA = (1 - (this.deathFrame/this.totalDeathFrames));
}

SimpleBrick.prototype.draw = function (f) {
	if (f === undefined) f = 1;
	GameObject.prototype.draw.call(this);
	gameCtx.lineWidth = 2;
	gameCtx.fillStyle = rgba(this.fillR,this.fillG,this.fillB,this.fillA*f);
	gameCtx.strokeStyle = rgba(this.strokeR,this.strokeG,this.strokeB,this.strokeA*f);
	gameCtx.fillRect(this.tl.x, this.tl.y, this.w, this.h);
	gameCtx.strokeRect(this.tl.x, this.tl.y, this.w, this.h);
}

SimpleBrick.prototype.damage = function (dam) {
	this.HP -= dam;
	this.hitFrame = ((2.0*this.HP/3.0)/this.maxHP)*this.totalHitFrames;
	if (this.hitFrame < 0) this.hitFrame = 0;
	if (this.HP < 0) {
		this.HP = 0;
		this.dying = true;
	}
}

/****************************************************************************************\
 █████╗ ██╗   ██╗██████╗ ██╗ ██████╗     ██████╗ ██╗      █████╗ ██╗   ██╗███████╗██████╗ 
██╔══██╗██║   ██║██╔══██╗██║██╔═══██╗    ██╔══██╗██║     ██╔══██╗╚██╗ ██╔╝██╔════╝██╔══██╗
███████║██║   ██║██║  ██║██║██║   ██║    ██████╔╝██║     ███████║ ╚████╔╝ █████╗  ██████╔╝
██╔══██║██║   ██║██║  ██║██║██║   ██║    ██╔═══╝ ██║     ██╔══██║  ╚██╔╝  ██╔══╝  ██╔══██╗
██║  ██║╚██████╔╝██████╔╝██║╚██████╔╝    ██║     ███████╗██║  ██║   ██║   ███████╗██║  ██║
╚═╝  ╚═╝ ╚═════╝ ╚═════╝ ╚═╝ ╚═════╝     ╚═╝     ╚══════╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═╝
\****************************************************************************************/

// may not be necessary to have a unified player where all sound is queued
audioPlayer = {
	notes: [],
	//bufferEmpty: true
};

audioPlayer.initAudio = function () {
	this.scriptNode = audioCtx.createScriptProcessor(1024, 0, 1); // mono sound, no input buffer
	this.scriptNode.connect(audioCtx.destination);
	this.scriptNode.onaudioprocess = this.audioCallback;
}

audioPlayer.audioCallback = function (e) {
	var outputData = e.outputBuffer.getChannelData(0);
	for (var sample = 0; sample < e.outputBuffer.length; sample++) {
		outputData[sample] = 0;
		for (var i = 0; i < audioPlayer.notes.length; i++) {
			if (audioPlayer.notes[i] && audioPlayer.notes[i].isPlaying) outputData[sample] += audioPlayer.notes[i].generate();
		}
	}
	for (var i = 0; i < audioPlayer.notes.length; i++) { // get rid of notes that are done
		if (!(audioPlayer.notes[i].isPlaying)) {
			audioPlayer.notes.splice(i,1);
			i--;
		}
	}
}

/**********************************\
████████╗ ██████╗ ███╗   ██╗███████╗
╚══██╔══╝██╔═══██╗████╗  ██║██╔════╝
   ██║   ██║   ██║██╔██╗ ██║█████╗  
   ██║   ██║   ██║██║╚██╗██║██╔══╝  
   ██║   ╚██████╔╝██║ ╚████║███████╗
   ╚═╝    ╚═════╝ ╚═╝  ╚═══╝╚══════╝
\**********************************/

function Tone(frequency, duration, gain) {
	this.frequency = frequency;
	this.duration = duration;
	this.gain = gain;
	this.formula = 'sawtooth'; // can be set to something else
	this.frame = 0; // current audio frame
	this.isPlaying = false; // set that when it's added to the notes array
	this.phase = Math.random()*2.0*Math.PI; // start with a random phase to prevent weird effects
	this.fourierCoeffs = [];
	this.fourierOffsets = [];
	// envelope
	this.envelope = {
		attack: 10, // in ms
		decay: 10,
		// sustain is governed by duration
		release: 20, // *past* specified duration
		attackGain: 2.0 // ratio of max power after attack to sustain power
	};
}

// calculates relevant frame points for the envelope
Tone.prototype.calculateFrames = function () {
	this.attackUntilFrame = this.envelope.attack/globalOptions.mspa;
	this.decayUntilFrame = this.attackUntilFrame + this.envelope.decay/globalOptions.mspa;
	this.sustainUntilFrame = this.duration/globalOptions.mspa;
	this.releaseUntilFrame = this.sustainUntilFrame + this.envelope.release/globalOptions.mspa;
}

// arbitrary stopping is not implemented -- notes stop automatically
Tone.prototype.play = function () {
	this.calculateFrames();
	this.isPlaying = true;
	audioPlayer.notes.push(this);
}

Tone.prototype.generateEnvelope = function () {
	if (this.frame < this.attackUntilFrame) {
		return (this.frame/this.attackUntilFrame)*this.envelope.attackGain;
	} else if (this.frame < this.decayUntilFrame) {
		return ((this.frame - this.attackUntilFrame)/(this.decayUntilFrame - this.attackUntilFrame))*(1.0 - this.envelope.attackGain) + this.envelope.attackGain;
	} else if (this.frame < this.sustainUntilFrame) {
		return 1;
	} else if (this.frame < this.releaseUntilFrame) {
		return 1.0 - (this.frame - this.sustainUntilFrame)/(this.releaseUntilFrame - this.sustainUntilFrame);
	} else {
		this.isPlaying = false;
		return 0;
	}
}

Tone.prototype.generate = function () {
	if (gameState.paused || !this.isPlaying) return 0;
	if (typeof this.formula == 'function') return this.formula();
	var sample = 0;
	if (this.formula == 'sawtooth') sample = (this.phase/Math.PI) - 1.0;
	else if (this.formula == 'sawtooth5') sample = this.fourier();
	else if (this.formula == 'square') sample = (this.phase < Math.PI) ? 1.0 : -1.0;
	else if (this.formula == 'sine') sample = Math.sin(this.phase);
	else if (this.formula == 'triangle') sample = 2.0*Math.abs((this.phase/Math.PI) - 1.0) - 1.0;
	sample *= this.gain*this.generateEnvelope();

	// update
	this.phase += Math.PI*this.frequency*globalOptions.mspa/500.0;
	while (this.phase > 2*Math.PI) this.phase -= 2*Math.PI;
	this.frame++;

	return sample;
}

Tone.prototype.fourier = function () {
	var sample = 0;
	for (var i = 0; i < this.fourierCoeffs.length; i++) {
		sample += this.fourierCoeffs[i]*Math.sin((i + 1)*(this.phase - this.fourierOffsets[i]));
	}
	return sample;
}

Tone.prototype.setFormula = function (formula) {
	if (formula == 'sawtooth' || formula == 'square' || formula == 'sine' || formula == 'triangle') this.formula = formula;
	else if (formula == 'sawtooth5') {
		this.fourierCoeffs = [1, 0.5, 1.0/3.0, 0.25, 0.2];
		this.fourierOffsets = [0, 0, 0, 0, 0];
		this.formula = formula;
	} else if (typeof formula == 'function') this.formula = formula;
}

/********************************************************************************\
███████╗ ██████╗ ██╗   ██╗███╗   ██╗██████╗     ██████╗  █████╗ ███╗   ██╗██╗  ██╗
██╔════╝██╔═══██╗██║   ██║████╗  ██║██╔══██╗    ██╔══██╗██╔══██╗████╗  ██║██║ ██╔╝
███████╗██║   ██║██║   ██║██╔██╗ ██║██║  ██║    ██████╔╝███████║██╔██╗ ██║█████╔╝ 
╚════██║██║   ██║██║   ██║██║╚██╗██║██║  ██║    ██╔══██╗██╔══██║██║╚██╗██║██╔═██╗ 
███████║╚██████╔╝╚██████╔╝██║ ╚████║██████╔╝    ██████╔╝██║  ██║██║ ╚████║██║  ██╗
╚══════╝ ╚═════╝  ╚═════╝ ╚═╝  ╚═══╝╚═════╝     ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝
\********************************************************************************/

// functions to create sounds
soundBank = {
	'death': function () {
		var sound = new Tone(2*C1, 150, 0.3);
		sound.envelope.attack = 20;
		sound.envelope.attackGain = 1.2;
		sound.play();
	},
	'wallClunk': function (p) {
		var sound = new Tone(4*C1, 100, 3*p);
		sound.setFormula('triangle');
		sound.play();
	},
	'paddleTouch': function (p) {
		var sound = new Tone(8*C1, 100, p);
		sound.play();
	},
	'paddleCapture': function () {
		var sound1 = new Tone(16*C1, 50, 0.09);
		var sound2 = new Tone(8*C1, 50, 0.03);
		sound1.setFormula('triangle');
		sound2.setFormula('square');
		sound1.envelope.release = 400;
		sound1.envelope.attackGain = 1.0;
		sound2.envelope.release = 200;
		sound2.envelope.attackGain = 1.5
		sound1.play();
		sound2.play();
	},
	'brickClunk': function (p, freq) {
		var sound1 = new Tone(16*C1, 50, 0.7*p);
		var sound2 = new Tone(freq, 50, 0.7*p);
		sound1.setFormula('sawtooth5');
		sound2.setFormula('sine');
		sound1.envelope.attackGain = 1.5;
		sound1.envelope.attack = 10;
		sound1.envelope.decay = 10;
		sound1.envelope.release = 50;
		sound2.envelope.attackGain = 1.5;
		sound2.envelope.attack = 10;
		sound2.envelope.decay = 10;
		sound2.envelope.release = 50;
		sound1.play();
		sound2.play();
	},
	'brickDestroy': function (p, freq) {
		var sound1 = new Tone(16*C1, 50, 0.7*p);
		var sound2 = new Tone(freq, 50, 0.7*p);
		sound1.setFormula('sawtooth5');
		sound2.setFormula('sine');
		sound1.envelope.attackGain = 4.0;
		sound1.envelope.attack = 5;
		sound1.envelope.decay = 10;
		sound1.envelope.release = 200;
		sound2.envelope.attackGain = 4.0;
		sound2.envelope.attack = 5;
		sound2.envelope.decay = 10;
		sound2.envelope.release = 200;
		sound1.play();
		sound2.play();
	}
};



		</script>
	</head>
	<body onload="load();">
		<canvas id="game" height=800 width=800 tabindex="0"></canvas>
		<br />
		press p to pause/unpause; click to lift the paddle and grab the ball or retrieve it if it's away too long
	</body>
</html>